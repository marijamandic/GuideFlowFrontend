{"version":3,"file":"compiler.mjs","sources":["../../../../../../packages/compiler/src/selector.ts","../../../../../../packages/compiler/src/core.ts","../../../../../../packages/compiler/src/i18n/big_integer.ts","../../../../../../packages/compiler/src/i18n/digest.ts","../../../../../../packages/compiler/src/output/output_ast.ts","../../../../../../packages/compiler/src/constant_pool.ts","../../../../../../packages/compiler/src/render3/r3_identifiers.ts","../../../../../../packages/compiler/src/util.ts","../../../../../../packages/compiler/src/output/source_map.ts","../../../../../../packages/compiler/src/output/abstract_emitter.ts","../../../../../../packages/compiler/src/render3/util.ts","../../../../../../packages/compiler/src/render3/r3_factory.ts","../../../../../../packages/compiler/src/render3/r3_ast.ts","../../../../../../packages/compiler/src/i18n/i18n_ast.ts","../../../../../../packages/compiler/src/i18n/serializers/serializer.ts","../../../../../../packages/compiler/src/i18n/serializers/xml_helper.ts","../../../../../../packages/compiler/src/i18n/serializers/xmb.ts","../../../../../../packages/compiler/src/render3/view/i18n/util.ts","../../../../../../packages/compiler/src/render3/view/util.ts","../../../../../../packages/compiler/src/injectable_compiler_2.ts","../../../../../../packages/compiler/src/assertions.ts","../../../../../../packages/compiler/src/ml_parser/interpolation_config.ts","../../../../../../packages/compiler/src/chars.ts","../../../../../../packages/compiler/src/parse_util.ts","../../../../../../packages/compiler/src/output/abstract_js_emitter.ts","../../../../../../packages/compiler/src/output/output_jit_trusted_types.ts","../../../../../../packages/compiler/src/output/output_jit.ts","../../../../../../packages/compiler/src/render3/r3_injector_compiler.ts","../../../../../../packages/compiler/src/render3/r3_jit.ts","../../../../../../packages/compiler/src/render3/r3_module_compiler.ts","../../../../../../packages/compiler/src/render3/r3_pipe_compiler.ts","../../../../../../packages/compiler/src/render3/view/api.ts","../../../../../../packages/compiler/src/expression_parser/ast.ts","../../../../../../packages/compiler/src/compiler_util/expression_converter.ts","../../../../../../packages/compiler/src/schema/dom_security_schema.ts","../../../../../../packages/compiler/src/shadow_css.ts","../../../../../../packages/compiler/src/ml_parser/tags.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/element.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/enums.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/traits.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/shared.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/update.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/expression.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/operations.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/create.ts","../../../../../../packages/compiler/src/template/pipeline/ir/src/ops/host.ts","../../../../../../packages/compiler/src/template/pipeline/src/compilation.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/var_counting.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/align_pipe_variadic_var_offset.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/any_cast.ts","../../../../../../packages/compiler/src/render3/view/style_parser.ts","../../../../../../packages/compiler/src/template/pipeline/src/util/elements.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/attribute_extraction.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/binding_specialization.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/chaining.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/const_collection.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/empty_elements.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/expand_safe_reads.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_advance.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/generate_variables.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/host_style_property_parsing.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/local_refs.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/namespace.ts","../../../../../../packages/compiler/src/template/pipeline/src/conversion.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/naming.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/next_context_merging.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/ng_container.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/no_listeners_on_templates.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/nonbindable.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/nullish_coalescing.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pipe_creation.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pipe_variadic.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/property_ordering.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pure_function_extraction.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/pure_literal_structures.ts","../../../../../../packages/compiler/src/template/pipeline/src/instruction.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/reify.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/remove_empty_bindings.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_contexts.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_dollar_event.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_names.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/resolve_sanitizers.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/save_restore_view.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/slot_allocation.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/style_binding_specialization.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/temporary_variables.ts","../../../../../../packages/compiler/src/template/pipeline/src/phases/variable_optimization.ts","../../../../../../packages/compiler/src/template/pipeline/src/emit.ts","../../../../../../packages/compiler/src/template/pipeline/src/ingest.ts","../../../../../../packages/compiler/src/template/pipeline/switch/index.ts","../../../../../../packages/compiler/src/render3/view/styling_builder.ts","../../../../../../packages/compiler/src/expression_parser/lexer.ts","../../../../../../packages/compiler/src/expression_parser/parser.ts","../../../../../../packages/compiler/src/ml_parser/ast.ts","../../../../../../packages/compiler/src/schema/element_schema_registry.ts","../../../../../../packages/compiler/src/schema/dom_element_schema_registry.ts","../../../../../../packages/compiler/src/ml_parser/html_tags.ts","../../../../../../packages/compiler/src/ml_parser/entities.ts","../../../../../../packages/compiler/src/ml_parser/lexer.ts","../../../../../../packages/compiler/src/ml_parser/parser.ts","../../../../../../packages/compiler/src/ml_parser/html_parser.ts","../../../../../../packages/compiler/src/ml_parser/html_whitespaces.ts","../../../../../../packages/compiler/src/output/map_util.ts","../../../../../../packages/compiler/src/schema/trusted_types_sinks.ts","../../../../../../packages/compiler/src/template_parser/binding_parser.ts","../../../../../../packages/compiler/src/style_url_resolver.ts","../../../../../../packages/compiler/src/template_parser/template_preparser.ts","../../../../../../packages/compiler/src/render3/r3_deferred_triggers.ts","../../../../../../packages/compiler/src/render3/r3_deferred_blocks.ts","../../../../../../packages/compiler/src/render3/r3_template_transform.ts","../../../../../../packages/compiler/src/render3/view/i18n/context.ts","../../../../../../packages/compiler/src/render3/view/i18n/icu_serializer.ts","../../../../../../packages/compiler/src/i18n/serializers/placeholder.ts","../../../../../../packages/compiler/src/i18n/i18n_parser.ts","../../../../../../packages/compiler/src/i18n/parse_util.ts","../../../../../../packages/compiler/src/render3/view/i18n/meta.ts","../../../../../../packages/compiler/src/render3/view/i18n/get_msg_utils.ts","../../../../../../packages/compiler/src/render3/view/i18n/localize_utils.ts","../../../../../../packages/compiler/src/render3/view/template.ts","../../../../../../packages/compiler/src/render3/view/compiler.ts","../../../../../../packages/compiler/src/resource_loader.ts","../../../../../../packages/compiler/src/jit_compiler_facade.ts","../../../../../../packages/compiler/src/version.ts","../../../../../../packages/compiler/src/config.ts","../../../../../../packages/compiler/src/i18n/extractor_merger.ts","../../../../../../packages/compiler/src/ml_parser/xml_tags.ts","../../../../../../packages/compiler/src/ml_parser/xml_parser.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff2.ts","../../../../../../packages/compiler/src/i18n/serializers/xtb.ts","../../../../../../packages/compiler/src/i18n/translation_bundle.ts","../../../../../../packages/compiler/src/i18n/i18n_html_parser.ts","../../../../../../packages/compiler/src/i18n/message_bundle.ts","../../../../../../packages/compiler/src/render3/partial/api.ts","../../../../../../packages/compiler/src/render3/view/t2_binder.ts","../../../../../../packages/compiler/src/render3/r3_class_metadata_compiler.ts","../../../../../../packages/compiler/src/render3/partial/class_metadata.ts","../../../../../../packages/compiler/src/render3/partial/util.ts","../../../../../../packages/compiler/src/render3/partial/directive.ts","../../../../../../packages/compiler/src/render3/partial/component.ts","../../../../../../packages/compiler/src/render3/partial/factory.ts","../../../../../../packages/compiler/src/render3/partial/injectable.ts","../../../../../../packages/compiler/src/render3/partial/injector.ts","../../../../../../packages/compiler/src/render3/partial/ng_module.ts","../../../../../../packages/compiler/src/render3/partial/pipe.ts","../../../../../../packages/compiler/src/compiler.ts","../../../../../../packages/compiler/public_api.ts","../../../../../../packages/compiler/compiler.ts","../../../../../../packages/compiler/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst _SELECTOR_REGEXP = new RegExp(\n    '(\\\\:not\\\\()|' +               // 1: \":not(\"\n        '(([\\\\.\\\\#]?)[-\\\\w]+)|' +  // 2: \"tag\"; 3: \".\"/\"#\";\n        // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n        // 4: attribute; 5: attribute_string; 6: attribute_value\n        '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +  // \"[name]\", \"[name=value]\",\n                                                                        // \"[name=\"value\"]\",\n                                                                        // \"[name='value']\"\n        '(\\\\))|' +                                                      // 7: \")\"\n        '(\\\\s*,\\\\s*)',                                                  // 8: \",\"\n    'g');\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0,  // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string|null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n          cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[]|null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.slice(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.slice(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n\n      if (attribute) {\n        current.addAttribute(\n            current.unescapeAttribute(attribute), match[SelectorRegexp.ATTRIBUTE_VALUE]);\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  /**\n   * Unescape `\\$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * but we might want to match an attribute that contains `$`.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to unescape.\n   * @returns the unescaped string.\n   */\n  unescapeAttribute(attr: string): string {\n    let result = '';\n    let escaping = false;\n    for (let i = 0; i < attr.length; i++) {\n      const char = attr.charAt(i);\n      if (char === '\\\\') {\n        escaping = true;\n        continue;\n      }\n      if (char === '$' && !escaping) {\n        throw new Error(\n            `Error in attribute selector \"${attr}\". ` +\n            `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\n      }\n      escaping = false;\n      result += char;\n    }\n    return result;\n  }\n\n  /**\n   * Escape `$` sequences from the CSS attribute selector.\n   *\n   * This is needed because `$` can have a special meaning in CSS selectors,\n   * with this method we are escaping `$` with `\\$'.\n   * [MDN web link for more\n   * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\n   * @param attr the attribute to escape.\n   * @returns the escaped string.Â \n   */\n  escapeAttribute(attr: string): string {\n    return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n  }\n\n  isElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n        this.notSelectors.length === 0;\n  }\n\n  hasElementSelector(): boolean {\n    return !!this.element;\n  }\n\n  setElement(element: string|null = null) {\n    this.element = element;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n\n  addClassName(name: string) {\n    this.classNames.push(name.toLowerCase());\n  }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.escapeAttribute(this.attrs[i]);\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null!;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n      cssSelector: CssSelector, callbackCtxt: T, listContext: SelectorListContext) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, selectable: SelectorContext<T>) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n   */\n  match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = false;\n    const element = cssSelector.element!;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n        result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n            this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n            this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n            result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name)!;\n        if (value) {\n          result =\n              this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name)!;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*')!;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n      map: Map<string, SelectorMatcher<T>>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n      public selector: CssSelector, public cbContext: T, public listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Attention:\n// This file duplicates types and values from @angular/core\n// so that we are able to make @angular/compiler independent of @angular/core.\n// This is important to prevent a build cycle, as @angular/core needs to\n// be compiled with the compiler.\n\nimport {CssSelector} from './selector';\n\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\nexport const emitDistinctChangesOnlyDefaultValue = true;\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n  None = 2,\n  ShadowDom = 3\n}\n\nexport enum ChangeDetectionStrategy {\n  OnPush = 0,\n  Default = 1\n}\n\nexport interface Input {\n  alias?: string;\n  required?: boolean;\n  transform?: (value: any) => any;\n}\n\nexport interface Output {\n  alias?: string;\n}\n\nexport interface HostBinding {\n  hostPropertyName?: string;\n}\n\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\n\nexport interface SchemaMetadata {\n  name: string;\n}\n\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n\nexport interface Type extends Function {\n  new(...args: any[]): any;\n}\nexport const Type = Function;\n\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n  /**\n   * This token is being injected into a pipe.\n   * @internal\n   */\n  ForPipe = 1 << 4,\n}\n\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n\n/**\n * Flags used to generate R3-style CSS Selectors. They are pasted from\n * core/src/render3/projection.ts because they cannot be referenced directly.\n */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// These are a copy the CSS types from core/src/render3/interfaces/projection.ts\n// They are duplicated here as they cannot be directly referenced from core.\nexport type R3CssSelector = (string|SelectorFlags)[];\nexport type R3CssSelectorList = R3CssSelector[];\n\nfunction parserSelectorToSimpleSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\n\nfunction parserSelectorToNegativeSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n\n  if (selector.element) {\n    return [\n      SelectorFlags.NOT | SelectorFlags.ELEMENT, selector.element, ...selector.attrs, ...classes\n    ];\n  } else if (selector.attrs.length) {\n    return [SelectorFlags.NOT | SelectorFlags.ATTRIBUTE, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ?\n        [SelectorFlags.NOT | SelectorFlags.CLASS, ...selector.classNames] :\n        [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector: CssSelector): R3CssSelector {\n  const positive = parserSelectorToSimpleSelector(selector);\n\n  const negative: R3CssSelectorList = selector.notSelectors && selector.notSelectors.length ?\n      selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n      [];\n\n  return positive.concat(...negative);\n}\n\nexport function parseSelectorToR3Selector(selector: string|null): R3CssSelectorList {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\n// Pasted from render3/interfaces/definition since it cannot be referenced directly\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10\n}\n\n// Pasted from render3/interfaces/node.ts\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div class=\"foo bar baz\">...<d/vi>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Represents a big integer using a buffer of its individual digits, with the least significant\n * digit stored at the beginning of the array (little endian).\n *\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\n * to reduce memory pressure of allocation for the digits array.\n */\nexport class BigInteger {\n  static zero(): BigInteger {\n    return new BigInteger([0]);\n  }\n\n  static one(): BigInteger {\n    return new BigInteger([1]);\n  }\n\n  /**\n   * Creates a big integer using its individual digits in little endian storage.\n   */\n  private constructor(private readonly digits: number[]) {}\n\n  /**\n   * Creates a clone of this instance.\n   */\n  clone(): BigInteger {\n    return new BigInteger(this.digits.slice());\n  }\n\n  /**\n   * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\n   * `this` but instead returns a new instance, unlike `addToSelf`.\n   */\n  add(other: BigInteger): BigInteger {\n    const result = this.clone();\n    result.addToSelf(other);\n    return result;\n  }\n\n  /**\n   * Adds `other` to the instance itself, thereby mutating its value.\n   */\n  addToSelf(other: BigInteger): void {\n    const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n    let carry = 0;\n    for (let i = 0; i < maxNrOfDigits; i++) {\n      let digitSum = carry;\n      if (i < this.digits.length) {\n        digitSum += this.digits[i];\n      }\n      if (i < other.digits.length) {\n        digitSum += other.digits[i];\n      }\n\n      if (digitSum >= 10) {\n        this.digits[i] = digitSum - 10;\n        carry = 1;\n      } else {\n        this.digits[i] = digitSum;\n        carry = 0;\n      }\n    }\n\n    // Apply a remaining carry if needed.\n    if (carry > 0) {\n      this.digits[maxNrOfDigits] = 1;\n    }\n  }\n\n  /**\n   * Builds the decimal string representation of the big integer. As this is stored in\n   * little endian, the digits are concatenated in reverse order.\n   */\n  toString(): string {\n    let res = '';\n    for (let i = this.digits.length - 1; i >= 0; i--) {\n      res += this.digits[i];\n    }\n    return res;\n  }\n}\n\n/**\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\n */\nexport class BigIntForMultiplication {\n  /**\n   * Stores all memoized power-of-twos, where each index represents `this.number * 2^index`.\n   */\n  private readonly powerOfTwos: BigInteger[];\n\n  constructor(value: BigInteger) {\n    this.powerOfTwos = [value];\n  }\n\n  /**\n   * Returns the big integer itself.\n   */\n  getValue(): BigInteger {\n    return this.powerOfTwos[0];\n  }\n\n  /**\n   * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\n   * value for `b` is represented by a storage model that is optimized for this computation.\n   *\n   * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\n   * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\n   * used as exponent into the power-of-two multiplication of `b`.\n   *\n   * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\n   * algorithm unrolls into the following iterations:\n   *\n   *  Iteration | num        | LSB  | b * 2^iter | Add? | product\n   * -----------|------------|------|------------|------|--------\n   *  0         | 0b00101010 | 0    | 1337       | No   | 0\n   *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\n   *  2         | 0b00001010 | 0    | 5348       | No   | 2674\n   *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\n   *  4         | 0b00000010 | 0    | 21392      | No   | 13370\n   *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\n   *  6         | 0b00000000 | 0    | 85568      | No   | 56154\n   *\n   * The computed product of 56154 is indeed the correct result.\n   *\n   * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\n   * power-of-two values to reduce the workload in computing those values.\n   */\n  multiplyBy(num: number): BigInteger {\n    const product = BigInteger.zero();\n    this.multiplyByAndAddTo(num, product);\n    return product;\n  }\n\n  /**\n   * See `multiplyBy()` for details. This function allows for the computed product to be added\n   * directly to the provided result big integer.\n   */\n  multiplyByAndAddTo(num: number, result: BigInteger): void {\n    for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n      if (num & 1) {\n        const value = this.getMultipliedByPowerOfTwo(exponent);\n        result.addToSelf(value);\n      }\n    }\n  }\n\n  /**\n   * Computes and memoizes the big integer value for `this.number * 2^exponent`.\n   */\n  private getMultipliedByPowerOfTwo(exponent: number): BigInteger {\n    // Compute the powers up until the requested exponent, where each value is computed from its\n    // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n    // added to itself) to reach `this.number * 2^exponent`.\n    for (let i = this.powerOfTwos.length; i <= exponent; i++) {\n      const previousPower = this.powerOfTwos[i - 1];\n      this.powerOfTwos[i] = previousPower.add(previousPower);\n    }\n    return this.powerOfTwos[exponent];\n  }\n}\n\n/**\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\n * representation that is lazily computed upon request.\n */\nexport class BigIntExponentiation {\n  private readonly exponents = [new BigIntForMultiplication(BigInteger.one())];\n\n  constructor(private readonly base: number) {}\n\n  /**\n   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\n   * further multiplication operations.\n   */\n  toThePowerOf(exponent: number): BigIntForMultiplication {\n    // Compute the results up until the requested exponent, where every value is computed from its\n    // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n    // to reach `this.base^exponent`.\n    for (let i = this.exponents.length; i <= exponent; i++) {\n      const value = this.exponents[i - 1].multiplyBy(this.base);\n      this.exponents[i] = new BigIntForMultiplication(value);\n    }\n    return this.exponents[exponent];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Byte} from '../util';\n\nimport {BigIntExponentiation} from './big_integer';\nimport * as i18n from './i18n_ast';\n\n/**\n * A lazily created TextEncoder instance for converting strings into UTF-8 bytes\n */\nlet textEncoder: TextEncoder|undefined;\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any {\n    return text.value;\n  }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid ?\n        `<ph tag name=\"${ph.startName}\"/>` :\n        `<ph tag name=\"${ph.startName}\">${\n            ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  override visitIcu(icu: i18n.Icu, context: any): any {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  textEncoder ??= new TextEncoder();\n  const utf8 = [...textEncoder.encode(str)];\n  const words32 = bytesToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = new Uint32Array(80);\n  let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[((len + 64 >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  // Convert the output parts to a 160-bit hexadecimal string\n  return toHexU32(a) + toHexU32(b) + toHexU32(c) + toHexU32(d) + toHexU32(e);\n}\n\n/**\n * Convert and format a number as a string representing a 32-bit unsigned hexadecimal number.\n * @param value The value to format as a string.\n * @returns A hexadecimal string representing the value.\n */\nfunction toHexU32(value: number): string {\n  // unsigned right shift of zero ensures an unsigned 32-bit number\n  return (value >>> 0).toString(16).padStart(8, '0');\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  textEncoder ??= new TextEncoder();\n  const utf8 = textEncoder.encode(str);\n  const view = new DataView(utf8.buffer, utf8.byteOffset, utf8.byteLength);\n\n  let hi = hash32(view, utf8.length, 0);\n  let lo = hash32(view, utf8.length, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    const meaningFingerprint = fingerprint(meaning);\n    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n  }\n\n  const hi = msgFingerprint[0];\n  const lo = msgFingerprint[1];\n\n  return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\n\nfunction hash32(view: DataView, length: number, c: number): number {\n  let a = 0x9e3779b9, b = 0x9e3779b9;\n  let index = 0;\n\n  const end = length - 12;\n  for (; index <= end; index += 12) {\n    a += view.getUint32(index, true);\n    b += view.getUint32(index + 4, true);\n    c += view.getUint32(index + 8, true);\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n\n  const remainder = length - index;\n\n  // the first byte of c is reserved for the length\n  c += length;\n\n  if (remainder >= 4) {\n    a += view.getUint32(index, true);\n    index += 4;\n\n    if (remainder >= 8) {\n      b += view.getUint32(index, true);\n      index += 4;\n\n      // Partial 32-bit word for c\n      if (remainder >= 9) {\n        c += view.getUint8(index++) << 8;\n      }\n      if (remainder >= 10) {\n        c += view.getUint8(index++) << 16;\n      }\n      if (remainder === 11) {\n        c += view.getUint8(index++) << 24;\n      }\n    } else {\n      // Partial 32-bit word for b\n      if (remainder >= 5) {\n        b += view.getUint8(index++);\n      }\n      if (remainder >= 6) {\n        b += view.getUint8(index++) << 8;\n      }\n      if (remainder === 7) {\n        b += view.getUint8(index++) << 16;\n      }\n    }\n  } else {\n    // Partial 32-bit word for a\n    if (remainder >= 1) {\n      a += view.getUint8(index++);\n    }\n    if (remainder >= 2) {\n      a += view.getUint8(index++) << 8;\n    }\n    if (remainder === 3) {\n      a += view.getUint8(index++) << 16;\n    }\n  }\n\n  return mix(a, b, c)[2];\n}\n\n// clang-format off\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a -= b; a -= c; a ^= c >>> 13;\n  b -= c; b -= a; b ^= a << 8;\n  c -= a; c -= b; c ^= b >>> 13;\n  a -= b; a -= c; a ^= c >>> 12;\n  b -= c; b -= a; b ^= a << 16;\n  c -= a; c -= b; c ^= b >>> 5;\n  a -= b; a -= c; a ^= c >>> 3;\n  b -= c; b -= a; b ^= a << 10;\n  c -= a; c -= b; c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64(a: [number, number], b: [number, number]): [number, number] {\n  const ah = a[0], al = a[1];\n  const bh = b[0], bl = b[1];\n  const result = add32to64(al, bl);\n  const carry = result[0];\n  const l = result[1];\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64(num: [number, number], count: number): [number, number] {\n  const hi = num[0], lo = num[1];\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction bytesToWords32(bytes: Byte[], endian: Endian): number[] {\n  const size = (bytes.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes: Byte[], index: number): Byte {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes: Byte[], index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\n\n/**\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\n *\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\n * exponent.\n */\nconst base256 = new BigIntExponentiation(256);\n\n/**\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\n * model as JS numbers are not accurate enough to represent the 64-bit number.\n *\n * Based on https://www.danvk.org/hex2dec.html\n */\nfunction wordsToDecimalString(hi: number, lo: number): string {\n  // Encode the four bytes in lo in the lower digits of the decimal number.\n  // Note: the multiplication results in lo itself but represented by a big integer using its\n  // decimal digits.\n  const decimal = base256.toThePowerOf(0).multiplyBy(lo);\n\n  // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n  // this multiplication factor is applied.\n  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n\n  return decimal.toString();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {computeMsgId} from '../i18n/digest';\nimport {Message} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\nimport {I18nMeta} from '../render3/view/i18n/meta';\n\n//// Types\nexport enum TypeModifier {\n  None = 0,\n  Const = 1 << 0,\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier = TypeModifier.None) {}\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(public name: BuiltinTypeName, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n      public value: Expression, modifiers?: TypeModifier, public typeParams: Type[]|null = null) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\n\nexport class ArrayType extends Type {\n  constructor(public of: Type, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\n\nexport class MapType extends Type {\n  public valueType: Type|null;\n  constructor(valueType: Type|null|undefined, modifiers?: TypeModifier) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitMapType(this, context);\n  }\n}\n\n\nexport class TransplantedType<T> extends Type {\n  constructor(readonly type: T, modifiers?: TypeModifier) {\n    super(modifiers);\n  }\n  override visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitTransplantedType(this, context);\n  }\n}\n\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n  visitTransplantedType(type: TransplantedType<unknown>, context: any): any;\n}\n\n///// Expressions\n\nexport enum UnaryOperator {\n  Minus,\n  Plus,\n}\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals,\n  NullishCoalesce,\n}\n\nexport function nullSafeIsEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T|null, other: T|null) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate<T>(\n    base: T[], other: T[], equivalentPredicate: (baseElement: T, otherElement: T) => boolean) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function areAllEquivalent<T extends {isEquivalent(other: T): boolean}>(\n    base: T[], other: T[]) {\n  return areAllEquivalentPredicate(\n      base, other, (baseElement: T, otherElement: T) => baseElement.isEquivalent(otherElement));\n}\n\nexport abstract class Expression {\n  public type: Type|null;\n  public sourceSpan: ParseSourceSpan|null;\n\n  constructor(type: Type|null|undefined, sourceSpan?: ParseSourceSpan|null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  abstract clone(): Expression;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan|null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callFn(params: Expression[], sourceSpan?: ParseSourceSpan|null, pure?: boolean):\n      InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n  }\n\n  instantiate(params: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null):\n      InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n      trueCase: Expression, falseCase: Expression|null = null,\n      sourceSpan?: ParseSourceSpan|null): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan|null, parens: boolean = true):\n      BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan|null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  nullishCoalesce(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n  }\n\n  toStmt(): Statement {\n    return new ExpressionStatement(this, null);\n  }\n}\n\nexport class ReadVarExpr extends Expression {\n  constructor(public name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  override clone(): ReadVarExpr {\n    return new ReadVarExpr(this.name, this.type, this.sourceSpan);\n  }\n\n  set(value: Expression): WriteVarExpr {\n    return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(public expr: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  override isConstant(): boolean {\n    return this.expr.isConstant();\n  }\n\n  override clone(): TypeofExpr {\n    return new TypeofExpr(this.expr.clone());\n  }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(public node: T, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n\n  override clone(): WrappedNodeExpr<T> {\n    return new WrappedNodeExpr(this.node, this.type, this.sourceSpan);\n  }\n}\n\nexport class WriteVarExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public name: string, value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteVarExpr(this, context);\n  }\n\n  override clone(): WriteVarExpr {\n    return new WriteVarExpr(this.name, this.value.clone(), this.type, this.sourceSpan);\n  }\n\n  toDeclStmt(type?: Type|null, modifiers?: StmtModifier): DeclareVarStmt {\n    return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n  }\n\n  toConstDecl(): DeclareVarStmt {\n    return this.toDeclStmt(INFERRED_TYPE, StmtModifier.Final);\n  }\n}\n\n\nexport class WriteKeyExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public index: Expression, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteKeyExpr(this, context);\n  }\n\n  override clone(): WriteKeyExpr {\n    return new WriteKeyExpr(\n        this.receiver.clone(), this.index.clone(), this.value.clone(), this.type, this.sourceSpan);\n  }\n}\n\n\nexport class WritePropExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public name: string, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWritePropExpr(this, context);\n  }\n\n  override clone(): WritePropExpr {\n    return new WritePropExpr(\n        this.receiver.clone(), this.name, this.value.clone(), this.type, this.sourceSpan);\n  }\n}\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n      public fn: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public pure = false) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for fn, which allows other logic to handle calls and property reads together.\n  get receiver(): Expression {\n    return this.fn;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n        areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n\n  override clone(): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(\n        this.fn.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan, this.pure);\n  }\n}\n\n\nexport class TaggedTemplateExpr extends Expression {\n  constructor(\n      public tag: Expression, public template: TemplateLiteral, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\n        areAllEquivalentPredicate(\n               this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\n        areAllEquivalent(this.template.expressions, e.template.expressions);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitTaggedTemplateExpr(this, context);\n  }\n\n  override clone(): TaggedTemplateExpr {\n    return new TaggedTemplateExpr(\n        this.tag.clone(), this.template.clone(), this.type, this.sourceSpan);\n  }\n}\n\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n      public classExpr: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n        areAllEquivalent(this.args, e.args);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n\n  override clone(): InstantiateExpr {\n    return new InstantiateExpr(\n        this.classExpr.clone(), this.args.map(arg => arg.clone()), this.type, this.sourceSpan);\n  }\n}\n\n\nexport class LiteralExpr extends Expression {\n  constructor(\n      public value: number|string|boolean|null|undefined, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n\n  override clone(): LiteralExpr {\n    return new LiteralExpr(this.value, this.type, this.sourceSpan);\n  }\n}\n\nexport class TemplateLiteral {\n  constructor(public elements: TemplateLiteralElement[], public expressions: Expression[]) {}\n\n  clone(): TemplateLiteral {\n    return new TemplateLiteral(\n        this.elements.map(el => el.clone()), this.expressions.map(expr => expr.clone()));\n  }\n}\nexport class TemplateLiteralElement {\n  rawText: string;\n  constructor(public text: string, public sourceSpan?: ParseSourceSpan, rawText?: string) {\n    // If `rawText` is not provided, try to extract the raw string from its\n    // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n    // string instead by escaping the following control sequences:\n    // - \"\\\" would otherwise indicate that the next character is a control character.\n    // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n    // indicate the end of the template literal element.\n    this.rawText =\n        rawText ?? sourceSpan?.toString() ?? escapeForTemplateLiteral(escapeSlashes(text));\n  }\n\n  clone(): TemplateLiteralElement {\n    return new TemplateLiteralElement(this.text, this.sourceSpan, this.rawText);\n  }\n}\n\nexport class LiteralPiece {\n  constructor(public text: string, public sourceSpan: ParseSourceSpan) {}\n}\nexport class PlaceholderPiece {\n  /**\n   * Create a new instance of a `PlaceholderPiece`.\n   *\n   * @param text the name of this placeholder (e.g. `PH_1`).\n   * @param sourceSpan the location of this placeholder in its localized message the source code.\n   * @param associatedMessage reference to another message that this placeholder is associated with.\n   * The `associatedMessage` is mainly used to provide a relationship to an ICU message that has\n   * been extracted out from the message containing the placeholder.\n   */\n  constructor(\n      public text: string, public sourceSpan: ParseSourceSpan, public associatedMessage?: Message) {\n  }\n}\n\nexport type MessagePiece = LiteralPiece|PlaceholderPiece;\n\nconst MEANING_SEPARATOR = '|';\nconst ID_SEPARATOR = '@@';\nconst LEGACY_ID_INDICATOR = 'â';\n\nexport class LocalizedString extends Expression {\n  constructor(\n      readonly metaBlock: I18nMeta, readonly messageParts: LiteralPiece[],\n      readonly placeHolderNames: PlaceholderPiece[], readonly expressions: Expression[],\n      sourceSpan?: ParseSourceSpan|null) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  override clone(): LocalizedString {\n    return new LocalizedString(\n        this.metaBlock, this.messageParts, this.placeHolderNames,\n        this.expressions.map(expr => expr.clone()), this.sourceSpan);\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): CookedRawString {\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(legacyId => {\n        metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\n      });\n    }\n    return createCookedRawString(\n        metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n  }\n\n  getMessagePartSourceSpan(i: number): ParseSourceSpan|null {\n    return this.messageParts[i]?.sourceSpan ?? this.sourceSpan;\n  }\n\n  getPlaceholderSourceSpan(i: number): ParseSourceSpan {\n    return this.placeHolderNames[i]?.sourceSpan ?? this.expressions[i]?.sourceSpan ??\n        this.sourceSpan;\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * The format is `:<placeholder-name>[@@<associated-id>]:`.\n   *\n   * The `associated-id` is the message id of the (usually an ICU) message to which this placeholder\n   * refers.\n   *\n   * @param partIndex The index of the message part to serialize.\n   */\n  serializeI18nTemplatePart(partIndex: number): CookedRawString {\n    const placeholder = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    let metaBlock = placeholder.text;\n    if (placeholder.associatedMessage?.legacyIds.length === 0) {\n      metaBlock += `${ID_SEPARATOR}${\n          computeMsgId(\n              placeholder.associatedMessage.messageString, placeholder.associatedMessage.meaning)}`;\n    }\n    return createCookedRawString(\n        metaBlock, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n  }\n}\n\n/**\n * A structure to hold the cooked and raw strings of a template literal element, along with its\n * source-span range.\n */\nexport interface CookedRawString {\n  cooked: string;\n  raw: string;\n  range: ParseSourceSpan|null;\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForTemplateLiteral = (str: string): string =>\n    str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(\n    metaBlock: string, messagePart: string, range: ParseSourceSpan|null): CookedRawString {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range,\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForTemplateLiteral(\n          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\n      range,\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n      public value: ExternalReference, type?: Type|null, public typeParams: Type[]|null = null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ExternalExpr && this.value.name === e.value.name &&\n        this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n\n  override clone(): ExternalExpr {\n    return new ExternalExpr(this.value, this.type, this.typeParams, this.sourceSpan);\n  }\n}\n\nexport class ExternalReference {\n  constructor(public moduleName: string|null, public name: string|null, public runtime?: any|null) {\n  }\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n      public condition: Expression, trueCase: Expression, public falseCase: Expression|null = null,\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n        this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n\n  override clone(): ConditionalExpr {\n    return new ConditionalExpr(\n        this.condition.clone(), this.trueCase.clone(), this.falseCase?.clone(), this.type,\n        this.sourceSpan);\n  }\n}\n\nexport class DynamicImportExpr extends Expression {\n  constructor(public url: string, sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof DynamicImportExpr && this.url === e.url;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitDynamicImportExpr(this, context);\n  }\n\n  override clone(): DynamicImportExpr {\n    return new DynamicImportExpr(this.url, this.sourceSpan);\n  }\n}\n\nexport class NotExpr extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n\n  override clone(): NotExpr {\n    return new NotExpr(this.condition.clone(), this.sourceSpan);\n  }\n}\n\nexport class FnParam {\n  constructor(public name: string, public type: Type|null = null) {}\n\n  isEquivalent(param: FnParam): boolean {\n    return this.name === param.name;\n  }\n\n  clone(): FnParam {\n    return new FnParam(this.name, this.type);\n  }\n}\n\n\nexport class FunctionExpr extends Expression {\n  constructor(\n      public params: FnParam[], public statements: Statement[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public name?: string|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n        areAllEquivalent(this.statements, e.statements);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers?: StmtModifier): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n        name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n\n  override clone(): FunctionExpr {\n    // TODO: Should we deep clone statements?\n    return new FunctionExpr(\n        this.params.map(p => p.clone()), this.statements, this.type, this.sourceSpan, this.name);\n  }\n}\n\n\nexport class UnaryOperatorExpr extends Expression {\n  constructor(\n      public operator: UnaryOperator, public expr: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || NUMBER_TYPE, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\n        this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitUnaryOperatorExpr(this, context);\n  }\n\n  override clone(): UnaryOperatorExpr {\n    return new UnaryOperatorExpr(\n        this.operator, this.expr.clone(), this.type, this.sourceSpan, this.parens);\n  }\n}\n\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n      public operator: BinaryOperator, lhs: Expression, public rhs: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n        this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n\n  override clone(): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(\n        this.operator, this.lhs.clone(), this.rhs.clone(), this.type, this.sourceSpan, this.parens);\n  }\n}\n\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n      public receiver: Expression, public name: string, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  // An alias for name, which allows other logic to handle property reads and keyed reads together.\n  get index() {\n    return this.name;\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name;\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): WritePropExpr {\n    return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n  }\n\n  override clone(): ReadPropExpr {\n    return new ReadPropExpr(this.receiver.clone(), this.name, this.type, this.sourceSpan);\n  }\n}\n\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n      public receiver: Expression, public index: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): WriteKeyExpr {\n    return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n  }\n\n  override clone(): ReadKeyExpr {\n    return new ReadKeyExpr(this.receiver.clone(), this.index.clone(), this.type, this.sourceSpan);\n  }\n}\n\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.isConstant());\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n\n  override clone(): LiteralArrayExpr {\n    return new LiteralArrayExpr(this.entries.map(e => e.clone()), this.type, this.sourceSpan);\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(public key: string, public value: Expression, public quoted: boolean) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n\n  clone(): LiteralMapEntry {\n    return new LiteralMapEntry(this.key, this.value.clone(), this.quoted);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type|null = null;\n  constructor(\n      public entries: LiteralMapEntry[], type?: MapType|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  override isConstant() {\n    return this.entries.every(e => e.value.isConstant());\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n\n  override clone(): LiteralMapExpr {\n    const entriesClone = this.entries.map(entry => entry.clone());\n    return new LiteralMapExpr(entriesClone, this.type as MapType | null, this.sourceSpan);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(public parts: Expression[], sourceSpan?: ParseSourceSpan|null) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  override isConstant() {\n    return false;\n  }\n\n  override visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n\n  override clone(): CommaExpr {\n    return new CommaExpr(this.parts.map(p => p.clone()));\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\n  visitWritePropExpr(expr: WritePropExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitDynamicImportExpr(ast: DynamicImportExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n}\n\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  None = 0,\n  Final = 1 << 0,\n  Private = 1 << 1,\n  Exported = 1 << 2,\n  Static = 1 << 3,\n}\n\nexport class LeadingComment {\n  constructor(public text: string, public multiline: boolean, public trailingNewline: boolean) {}\n  toString() {\n    return this.multiline ? ` ${this.text} ` : this.text;\n  }\n}\nexport class JSDocComment extends LeadingComment {\n  constructor(public tags: JSDocTag[]) {\n    super('', /* multiline */ true, /* trailingNewline */ true);\n  }\n  override toString(): string {\n    return serializeTags(this.tags);\n  }\n}\n\nexport abstract class Statement {\n  constructor(\n      public modifiers: StmtModifier = StmtModifier.None,\n      public sourceSpan: ParseSourceSpan|null = null, public leadingComments?: LeadingComment[]) {}\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean {\n    return (this.modifiers & modifier) !== 0;\n  }\n\n  addLeadingComment(leadingComment: LeadingComment): void {\n    this.leadingComments = this.leadingComments ?? [];\n    this.leadingComments.push(leadingComment);\n  }\n}\n\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public value?: Expression, type?: Type|null, modifiers?: StmtModifier,\n      sourceSpan?: ParseSourceSpan|null, leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || (value && value.type) || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n        (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public params: FnParam[], public statements: Statement[],\n      type?: Type|null, modifiers?: StmtModifier, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(modifiers, sourceSpan, leadingComments);\n    this.type = type || null;\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n        areAllEquivalent(this.statements, stmt.statements);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(\n      public expr: Expression, sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\n\nexport class ReturnStatement extends Statement {\n  constructor(\n      public value: Expression, sourceSpan: ParseSourceSpan|null = null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class IfStmt extends Statement {\n  constructor(\n      public condition: Expression, public trueCase: Statement[],\n      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null,\n      leadingComments?: LeadingComment[]) {\n    super(StmtModifier.None, sourceSpan, leadingComments);\n  }\n  override isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n        areAllEquivalent(this.trueCase, stmt.trueCase) &&\n        areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  override visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n}\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any {\n    return ast;\n  }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitMapType(type: MapType, context: any): any {\n    return this.visitType(type, context);\n  }\n  visitTransplantedType(type: TransplantedType<unknown>, context: any): any {\n    return type;\n  }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return ast;\n  }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitWriteVarExpr(ast: WriteVarExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWriteKeyExpr(ast: WriteKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWritePropExpr(ast: WritePropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitDynamicImportExpr(ast: DynamicImportExpr, context: any) {\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitTaggedTemplateExpr(ast: TaggedTemplateExpr, context: any): any {\n    ast.tag.visitExpression(this, context);\n    this.visitAllExpressions(ast.template.expressions, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase!.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitUnaryOperatorExpr(ast: UnaryOperatorExpr, context: any): any {\n    ast.expr.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n}\n\nexport function leadingComment(\n    text: string, multiline: boolean = false, trailingNewline: boolean = true): LeadingComment {\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nexport function jsDocComment(tags: JSDocTag[] = []): JSDocComment {\n  return new JSDocComment(tags);\n}\n\nexport function variable(\n    name: string, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n    id: ExternalReference, typeParams: Type[]|null = null,\n    sourceSpan?: ParseSourceSpan|null): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n    id: ExternalReference, typeParams?: Type[]|null, typeModifiers?: TypeModifier): ExpressionType|\n    null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n    expr: Expression, typeModifiers?: TypeModifier, typeParams?: Type[]|null): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function transplantedType<T>(type: T, typeModifiers?: TypeModifier): TransplantedType<T> {\n  return new TransplantedType(type, typeModifiers);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n    values: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n    values: {key: string, quoted: boolean, value: Expression}[],\n    type: MapType|null = null): LiteralMapExpr {\n  return new LiteralMapExpr(\n      values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\n\nexport function unary(\n    operator: UnaryOperator, expr: Expression, type?: Type,\n    sourceSpan?: ParseSourceSpan|null): UnaryOperatorExpr {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan|null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function fn(\n    params: FnParam[], body: Statement[], type?: Type|null, sourceSpan?: ParseSourceSpan|null,\n    name?: string|null): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function ifStmt(\n    condition: Expression, thenClause: Statement[], elseClause?: Statement[],\n    sourceSpan?: ParseSourceSpan, leadingComments?: LeadingComment[]) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nexport function taggedTemplate(\n    tag: Expression, template: TemplateLiteral, type?: Type|null,\n    sourceSpan?: ParseSourceSpan|null): TaggedTemplateExpr {\n  return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\n\nexport function literal(\n    value: any, type?: Type|null, sourceSpan?: ParseSourceSpan|null): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n    metaBlock: I18nMeta, messageParts: LiteralPiece[], placeholderNames: PlaceholderPiece[],\n    expressions: Expression[], sourceSpan?: ParseSourceSpan|null): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n  Suppress = 'suppress',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag = {\n  // `tagName` is e.g. \"param\" in an `@param` declaration\n  tagName: JSDocTagName|string,\n  // Any remaining text on the tag, e.g. the description\n  text?: string,\n}|{\n  // no `tagName` for plain text documentation that occurs before any `@param` lines\n  tagName?: undefined, text: string,\n};\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return `*${tagToString(tags[0])} `;\n  }\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\n\nconst CONSTANT_PREFIX = '_c';\n\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\nconst UNKNOWN_VALUE_KEY = o.variable('<unknown>');\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\n * for strings that reach a certain length threshold. This constant defines the length threshold for\n * strings.\n */\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  shared = false;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): FixupExpression {\n    throw new Error(`Not supported.`);\n  }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private sharedConstants = new Map<string, o.Expression>();\n\n  private nextNameIndex = 0;\n\n  constructor(private readonly isClosureCompilerEnabled: boolean = false) {}\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if ((literal instanceof o.LiteralExpr && !isLongStringLiteral(literal)) ||\n        literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = GenericKeyFn.INSTANCE.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      let definition: o.WriteVarExpr;\n      let usage: o.Expression;\n      if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n        // For string literals, Closure will **always** inline the string at\n        // **all** usages, duplicating it each time. For large strings, this\n        // unnecessarily bloats bundle size. To work around this restriction, we\n        // wrap the string in a function, and call that function for each usage.\n        // This tricks Closure into using inline logic for functions instead of\n        // string literals. Function calls are only inlined if the body is small\n        // enough to be worth it. By doing this, very large strings will be\n        // shared across multiple usages, rather than duplicating the string at\n        // each usage site.\n        //\n        // const myStr = function() { return \"very very very long string\"; };\n        // const usage1 = myStr();\n        // const usage2 = myStr();\n        definition = o.variable(name).set(new o.FunctionExpr(\n            [],  // Params.\n            [\n              // Statements.\n              new o.ReturnStatement(literal),\n            ],\n            ));\n        usage = o.variable(name).callFn([]);\n      } else {\n        // Just declare and use the variable directly, without a function call\n        // indirection. This saves a few bytes and avoids an unnecessary call.\n        definition = o.variable(name).set(literal);\n        usage = o.variable(name);\n      }\n\n      this.statements.push(definition.toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      fixup.fixup(usage);\n    }\n\n    return fixup;\n  }\n\n  getSharedConstant(def: SharedConstantDefinition, expr: o.Expression): o.Expression {\n    const key = def.keyOf(expr);\n    if (!this.sharedConstants.has(key)) {\n      const id = this.freshName();\n      this.sharedConstants.set(key, o.variable(id));\n      this.statements.push(def.toSharedConstantDeclaration(id, expr));\n    }\n    return this.sharedConstants.get(key)!;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\n      const key = GenericKeyFn.INSTANCE.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n                                quoted: e.quoted\n                              })));\n      const key = GenericKeyFn.INSTANCE.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name!, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(o.variable(name)\n                               .set(pureFunctionDeclaration)\n                               .toDeclStmt(o.INFERRED_TYPE, o.StmtModifier.Final));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string {\n    return `${prefix}${this.nextNameIndex++}`;\n  }\n\n  private freshName(): string {\n    return this.uniqueName(CONSTANT_PREFIX);\n  }\n}\n\nexport interface ExpressionKeyFn {\n  keyOf(expr: o.Expression): string;\n}\n\nexport interface SharedConstantDefinition extends ExpressionKeyFn {\n  toSharedConstantDeclaration(declName: string, keyExpr: o.Expression): o.Statement;\n}\n\nexport class GenericKeyFn implements ExpressionKeyFn {\n  static readonly INSTANCE = new GenericKeyFn();\n\n  keyOf(expr: o.Expression): string {\n    if (expr instanceof o.LiteralExpr && typeof expr.value === 'string') {\n      return `\"${expr.value}\"`;\n    } else if (expr instanceof o.LiteralExpr) {\n      return String(expr.value);\n    } else if (expr instanceof o.LiteralArrayExpr) {\n      const entries: string[] = [];\n      for (const entry of expr.entries) {\n        entries.push(this.keyOf(entry));\n      }\n      return `[${entries.join(',')}]`;\n    } else if (expr instanceof o.LiteralMapExpr) {\n      const entries: string[] = [];\n      for (const entry of expr.entries) {\n        let key = entry.key;\n        if (entry.quoted) {\n          key = `\"${key}\"`;\n        }\n        entries.push(key + ':' + this.keyOf(entry.value));\n      }\n      return `{${entries.join(',')}}`;\n    } else if (expr instanceof o.ExternalExpr) {\n      return `import(\"${expr.value.moduleName}\", ${expr.value.name})`;\n    } else if (expr instanceof o.ReadVarExpr) {\n      return `read(${expr.name})`;\n    } else if (expr instanceof o.TypeofExpr) {\n      return `typeof(${this.keyOf(expr.expr)})`;\n    } else {\n      throw new Error(\n          `${this.constructor.name} does not handle expressions of type ${expr.constructor.name}`);\n    }\n  }\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr: o.Expression): boolean {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string' &&\n      expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nconst CORE = '@angular/core';\n\nexport class Identifiers {\n  /* Methods */\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n\n  static core: o.ExternalReference = {name: null, moduleName: CORE};\n\n  /* Instructions */\n  static namespaceHTML: o.ExternalReference = {name: 'ÉµÉµnamespaceHTML', moduleName: CORE};\n\n  static namespaceMathML: o.ExternalReference = {name: 'ÉµÉµnamespaceMathML', moduleName: CORE};\n\n  static namespaceSVG: o.ExternalReference = {name: 'ÉµÉµnamespaceSVG', moduleName: CORE};\n\n  static element: o.ExternalReference = {name: 'ÉµÉµelement', moduleName: CORE};\n\n  static elementStart: o.ExternalReference = {name: 'ÉµÉµelementStart', moduleName: CORE};\n\n  static elementEnd: o.ExternalReference = {name: 'ÉµÉµelementEnd', moduleName: CORE};\n\n  static advance: o.ExternalReference = {name: 'ÉµÉµadvance', moduleName: CORE};\n\n  static syntheticHostProperty:\n      o.ExternalReference = {name: 'ÉµÉµsyntheticHostProperty', moduleName: CORE};\n\n  static syntheticHostListener:\n      o.ExternalReference = {name: 'ÉµÉµsyntheticHostListener', moduleName: CORE};\n\n  static attribute: o.ExternalReference = {name: 'ÉµÉµattribute', moduleName: CORE};\n\n  static attributeInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate1', moduleName: CORE};\n  static attributeInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate2', moduleName: CORE};\n  static attributeInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate3', moduleName: CORE};\n  static attributeInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate4', moduleName: CORE};\n  static attributeInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate5', moduleName: CORE};\n  static attributeInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate6', moduleName: CORE};\n  static attributeInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate7', moduleName: CORE};\n  static attributeInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate8', moduleName: CORE};\n  static attributeInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolateV', moduleName: CORE};\n\n  static classProp: o.ExternalReference = {name: 'ÉµÉµclassProp', moduleName: CORE};\n\n  static elementContainerStart:\n      o.ExternalReference = {name: 'ÉµÉµelementContainerStart', moduleName: CORE};\n\n  static elementContainerEnd:\n      o.ExternalReference = {name: 'ÉµÉµelementContainerEnd', moduleName: CORE};\n\n  static elementContainer: o.ExternalReference = {name: 'ÉµÉµelementContainer', moduleName: CORE};\n\n  static styleMap: o.ExternalReference = {name: 'ÉµÉµstyleMap', moduleName: CORE};\n\n  static styleMapInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate1', moduleName: CORE};\n  static styleMapInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate2', moduleName: CORE};\n  static styleMapInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate3', moduleName: CORE};\n  static styleMapInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate4', moduleName: CORE};\n  static styleMapInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate5', moduleName: CORE};\n  static styleMapInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate6', moduleName: CORE};\n  static styleMapInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate7', moduleName: CORE};\n  static styleMapInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolate8', moduleName: CORE};\n  static styleMapInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµstyleMapInterpolateV', moduleName: CORE};\n\n  static classMap: o.ExternalReference = {name: 'ÉµÉµclassMap', moduleName: CORE};\n\n  static classMapInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate1', moduleName: CORE};\n  static classMapInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate2', moduleName: CORE};\n  static classMapInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate3', moduleName: CORE};\n  static classMapInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate4', moduleName: CORE};\n  static classMapInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate5', moduleName: CORE};\n  static classMapInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate6', moduleName: CORE};\n  static classMapInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate7', moduleName: CORE};\n  static classMapInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate8', moduleName: CORE};\n  static classMapInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolateV', moduleName: CORE};\n\n  static styleProp: o.ExternalReference = {name: 'ÉµÉµstyleProp', moduleName: CORE};\n\n  static stylePropInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate1', moduleName: CORE};\n  static stylePropInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate2', moduleName: CORE};\n  static stylePropInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate3', moduleName: CORE};\n  static stylePropInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate4', moduleName: CORE};\n  static stylePropInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate5', moduleName: CORE};\n  static stylePropInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate6', moduleName: CORE};\n  static stylePropInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate7', moduleName: CORE};\n  static stylePropInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate8', moduleName: CORE};\n  static stylePropInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolateV', moduleName: CORE};\n\n  static nextContext: o.ExternalReference = {name: 'ÉµÉµnextContext', moduleName: CORE};\n\n  static resetView: o.ExternalReference = {name: 'ÉµÉµresetView', moduleName: CORE};\n\n  static templateCreate: o.ExternalReference = {name: 'ÉµÉµtemplate', moduleName: CORE};\n\n  static defer: o.ExternalReference = {name: 'ÉµÉµdefer', moduleName: CORE};\n\n  static text: o.ExternalReference = {name: 'ÉµÉµtext', moduleName: CORE};\n\n  static enableBindings: o.ExternalReference = {name: 'ÉµÉµenableBindings', moduleName: CORE};\n\n  static disableBindings: o.ExternalReference = {name: 'ÉµÉµdisableBindings', moduleName: CORE};\n\n  static getCurrentView: o.ExternalReference = {name: 'ÉµÉµgetCurrentView', moduleName: CORE};\n\n  static textInterpolate: o.ExternalReference = {name: 'ÉµÉµtextInterpolate', moduleName: CORE};\n  static textInterpolate1: o.ExternalReference = {name: 'ÉµÉµtextInterpolate1', moduleName: CORE};\n  static textInterpolate2: o.ExternalReference = {name: 'ÉµÉµtextInterpolate2', moduleName: CORE};\n  static textInterpolate3: o.ExternalReference = {name: 'ÉµÉµtextInterpolate3', moduleName: CORE};\n  static textInterpolate4: o.ExternalReference = {name: 'ÉµÉµtextInterpolate4', moduleName: CORE};\n  static textInterpolate5: o.ExternalReference = {name: 'ÉµÉµtextInterpolate5', moduleName: CORE};\n  static textInterpolate6: o.ExternalReference = {name: 'ÉµÉµtextInterpolate6', moduleName: CORE};\n  static textInterpolate7: o.ExternalReference = {name: 'ÉµÉµtextInterpolate7', moduleName: CORE};\n  static textInterpolate8: o.ExternalReference = {name: 'ÉµÉµtextInterpolate8', moduleName: CORE};\n  static textInterpolateV: o.ExternalReference = {name: 'ÉµÉµtextInterpolateV', moduleName: CORE};\n\n  static restoreView: o.ExternalReference = {name: 'ÉµÉµrestoreView', moduleName: CORE};\n\n  static pureFunction0: o.ExternalReference = {name: 'ÉµÉµpureFunction0', moduleName: CORE};\n  static pureFunction1: o.ExternalReference = {name: 'ÉµÉµpureFunction1', moduleName: CORE};\n  static pureFunction2: o.ExternalReference = {name: 'ÉµÉµpureFunction2', moduleName: CORE};\n  static pureFunction3: o.ExternalReference = {name: 'ÉµÉµpureFunction3', moduleName: CORE};\n  static pureFunction4: o.ExternalReference = {name: 'ÉµÉµpureFunction4', moduleName: CORE};\n  static pureFunction5: o.ExternalReference = {name: 'ÉµÉµpureFunction5', moduleName: CORE};\n  static pureFunction6: o.ExternalReference = {name: 'ÉµÉµpureFunction6', moduleName: CORE};\n  static pureFunction7: o.ExternalReference = {name: 'ÉµÉµpureFunction7', moduleName: CORE};\n  static pureFunction8: o.ExternalReference = {name: 'ÉµÉµpureFunction8', moduleName: CORE};\n  static pureFunctionV: o.ExternalReference = {name: 'ÉµÉµpureFunctionV', moduleName: CORE};\n\n  static pipeBind1: o.ExternalReference = {name: 'ÉµÉµpipeBind1', moduleName: CORE};\n  static pipeBind2: o.ExternalReference = {name: 'ÉµÉµpipeBind2', moduleName: CORE};\n  static pipeBind3: o.ExternalReference = {name: 'ÉµÉµpipeBind3', moduleName: CORE};\n  static pipeBind4: o.ExternalReference = {name: 'ÉµÉµpipeBind4', moduleName: CORE};\n  static pipeBindV: o.ExternalReference = {name: 'ÉµÉµpipeBindV', moduleName: CORE};\n\n  static hostProperty: o.ExternalReference = {name: 'ÉµÉµhostProperty', moduleName: CORE};\n\n  static property: o.ExternalReference = {name: 'ÉµÉµproperty', moduleName: CORE};\n\n  static propertyInterpolate:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate', moduleName: CORE};\n  static propertyInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate1', moduleName: CORE};\n  static propertyInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate2', moduleName: CORE};\n  static propertyInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate3', moduleName: CORE};\n  static propertyInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate4', moduleName: CORE};\n  static propertyInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate5', moduleName: CORE};\n  static propertyInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate6', moduleName: CORE};\n  static propertyInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate7', moduleName: CORE};\n  static propertyInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate8', moduleName: CORE};\n  static propertyInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolateV', moduleName: CORE};\n\n  static i18n: o.ExternalReference = {name: 'ÉµÉµi18n', moduleName: CORE};\n  static i18nAttributes: o.ExternalReference = {name: 'ÉµÉµi18nAttributes', moduleName: CORE};\n  static i18nExp: o.ExternalReference = {name: 'ÉµÉµi18nExp', moduleName: CORE};\n  static i18nStart: o.ExternalReference = {name: 'ÉµÉµi18nStart', moduleName: CORE};\n  static i18nEnd: o.ExternalReference = {name: 'ÉµÉµi18nEnd', moduleName: CORE};\n  static i18nApply: o.ExternalReference = {name: 'ÉµÉµi18nApply', moduleName: CORE};\n  static i18nPostprocess: o.ExternalReference = {name: 'ÉµÉµi18nPostprocess', moduleName: CORE};\n\n  static pipe: o.ExternalReference = {name: 'ÉµÉµpipe', moduleName: CORE};\n\n  static projection: o.ExternalReference = {name: 'ÉµÉµprojection', moduleName: CORE};\n  static projectionDef: o.ExternalReference = {name: 'ÉµÉµprojectionDef', moduleName: CORE};\n\n  static reference: o.ExternalReference = {name: 'ÉµÉµreference', moduleName: CORE};\n\n  static inject: o.ExternalReference = {name: 'ÉµÉµinject', moduleName: CORE};\n\n  static injectAttribute: o.ExternalReference = {name: 'ÉµÉµinjectAttribute', moduleName: CORE};\n\n  static directiveInject: o.ExternalReference = {name: 'ÉµÉµdirectiveInject', moduleName: CORE};\n  static invalidFactory: o.ExternalReference = {name: 'ÉµÉµinvalidFactory', moduleName: CORE};\n  static invalidFactoryDep: o.ExternalReference = {name: 'ÉµÉµinvalidFactoryDep', moduleName: CORE};\n\n  static templateRefExtractor:\n      o.ExternalReference = {name: 'ÉµÉµtemplateRefExtractor', moduleName: CORE};\n\n  static forwardRef: o.ExternalReference = {name: 'forwardRef', moduleName: CORE};\n  static resolveForwardRef: o.ExternalReference = {name: 'resolveForwardRef', moduleName: CORE};\n\n  static ÉµÉµdefineInjectable: o.ExternalReference = {name: 'ÉµÉµdefineInjectable', moduleName: CORE};\n  static declareInjectable: o.ExternalReference = {name: 'ÉµÉµngDeclareInjectable', moduleName: CORE};\n  static InjectableDeclaration:\n      o.ExternalReference = {name: 'ÉµÉµInjectableDeclaration', moduleName: CORE};\n\n  static resolveWindow: o.ExternalReference = {name: 'ÉµÉµresolveWindow', moduleName: CORE};\n  static resolveDocument: o.ExternalReference = {name: 'ÉµÉµresolveDocument', moduleName: CORE};\n  static resolveBody: o.ExternalReference = {name: 'ÉµÉµresolveBody', moduleName: CORE};\n\n  static defineComponent: o.ExternalReference = {name: 'ÉµÉµdefineComponent', moduleName: CORE};\n  static declareComponent: o.ExternalReference = {name: 'ÉµÉµngDeclareComponent', moduleName: CORE};\n\n  static setComponentScope: o.ExternalReference = {name: 'ÉµÉµsetComponentScope', moduleName: CORE};\n\n  static ChangeDetectionStrategy: o.ExternalReference = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n  };\n  static ViewEncapsulation: o.ExternalReference = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n  };\n\n  static ComponentDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµComponentDeclaration',\n    moduleName: CORE,\n  };\n\n  static FactoryDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµFactoryDeclaration',\n    moduleName: CORE,\n  };\n  static declareFactory: o.ExternalReference = {name: 'ÉµÉµngDeclareFactory', moduleName: CORE};\n  static FactoryTarget: o.ExternalReference = {name: 'ÉµÉµFactoryTarget', moduleName: CORE};\n\n  static defineDirective: o.ExternalReference = {name: 'ÉµÉµdefineDirective', moduleName: CORE};\n  static declareDirective: o.ExternalReference = {name: 'ÉµÉµngDeclareDirective', moduleName: CORE};\n\n  static DirectiveDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµDirectiveDeclaration',\n    moduleName: CORE,\n  };\n\n  static InjectorDef: o.ExternalReference = {name: 'ÉµÉµInjectorDef', moduleName: CORE};\n  static InjectorDeclaration:\n      o.ExternalReference = {name: 'ÉµÉµInjectorDeclaration', moduleName: CORE};\n\n  static defineInjector: o.ExternalReference = {name: 'ÉµÉµdefineInjector', moduleName: CORE};\n  static declareInjector: o.ExternalReference = {name: 'ÉµÉµngDeclareInjector', moduleName: CORE};\n\n  static NgModuleDeclaration: o.ExternalReference = {\n    name: 'ÉµÉµNgModuleDeclaration',\n    moduleName: CORE,\n  };\n\n  static ModuleWithProviders: o.ExternalReference = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n  };\n\n  static defineNgModule: o.ExternalReference = {name: 'ÉµÉµdefineNgModule', moduleName: CORE};\n  static declareNgModule: o.ExternalReference = {name: 'ÉµÉµngDeclareNgModule', moduleName: CORE};\n  static setNgModuleScope: o.ExternalReference = {name: 'ÉµÉµsetNgModuleScope', moduleName: CORE};\n  static registerNgModuleType:\n      o.ExternalReference = {name: 'ÉµÉµregisterNgModuleType', moduleName: CORE};\n\n\n  static PipeDeclaration: o.ExternalReference = {name: 'ÉµÉµPipeDeclaration', moduleName: CORE};\n\n  static definePipe: o.ExternalReference = {name: 'ÉµÉµdefinePipe', moduleName: CORE};\n  static declarePipe: o.ExternalReference = {name: 'ÉµÉµngDeclarePipe', moduleName: CORE};\n\n  static declareClassMetadata:\n      o.ExternalReference = {name: 'ÉµÉµngDeclareClassMetadata', moduleName: CORE};\n  static setClassMetadata: o.ExternalReference = {name: 'ÉµsetClassMetadata', moduleName: CORE};\n\n  static queryRefresh: o.ExternalReference = {name: 'ÉµÉµqueryRefresh', moduleName: CORE};\n  static viewQuery: o.ExternalReference = {name: 'ÉµÉµviewQuery', moduleName: CORE};\n  static loadQuery: o.ExternalReference = {name: 'ÉµÉµloadQuery', moduleName: CORE};\n  static contentQuery: o.ExternalReference = {name: 'ÉµÉµcontentQuery', moduleName: CORE};\n\n  static NgOnChangesFeature: o.ExternalReference = {name: 'ÉµÉµNgOnChangesFeature', moduleName: CORE};\n\n  static InheritDefinitionFeature:\n      o.ExternalReference = {name: 'ÉµÉµInheritDefinitionFeature', moduleName: CORE};\n\n  static CopyDefinitionFeature:\n      o.ExternalReference = {name: 'ÉµÉµCopyDefinitionFeature', moduleName: CORE};\n\n  static StandaloneFeature: o.ExternalReference = {name: 'ÉµÉµStandaloneFeature', moduleName: CORE};\n\n  static ProvidersFeature: o.ExternalReference = {name: 'ÉµÉµProvidersFeature', moduleName: CORE};\n\n  static HostDirectivesFeature:\n      o.ExternalReference = {name: 'ÉµÉµHostDirectivesFeature', moduleName: CORE};\n\n  static InputTransformsFeatureFeature:\n      o.ExternalReference = {name: 'ÉµÉµInputTransformsFeature', moduleName: CORE};\n\n  static listener: o.ExternalReference = {name: 'ÉµÉµlistener', moduleName: CORE};\n\n  static getInheritedFactory: o.ExternalReference = {\n    name: 'ÉµÉµgetInheritedFactory',\n    moduleName: CORE,\n  };\n\n  // sanitization-related functions\n  static sanitizeHtml: o.ExternalReference = {name: 'ÉµÉµsanitizeHtml', moduleName: CORE};\n  static sanitizeStyle: o.ExternalReference = {name: 'ÉµÉµsanitizeStyle', moduleName: CORE};\n  static sanitizeResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµsanitizeResourceUrl', moduleName: CORE};\n  static sanitizeScript: o.ExternalReference = {name: 'ÉµÉµsanitizeScript', moduleName: CORE};\n  static sanitizeUrl: o.ExternalReference = {name: 'ÉµÉµsanitizeUrl', moduleName: CORE};\n  static sanitizeUrlOrResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµsanitizeUrlOrResourceUrl', moduleName: CORE};\n  static trustConstantHtml: o.ExternalReference = {name: 'ÉµÉµtrustConstantHtml', moduleName: CORE};\n  static trustConstantResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµtrustConstantResourceUrl', moduleName: CORE};\n  static validateIframeAttribute:\n      o.ExternalReference = {name: 'ÉµÉµvalidateIframeAttribute', moduleName: CORE};\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nexport function noUndefined<T>(val: T|undefined): T {\n  return val === undefined ? null! : val;\n}\n\nexport function error(msg: string): never {\n  throw new Error(`Internal Error: ${msg}`);\n}\n\n// Escape characters that have a special meaning in Regular Expressions\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nexport type Byte = number;\n\nexport function utf8Encode(str: string): Byte[] {\n  let encoded: Byte[] = [];\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(\n          (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(\n          ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n          ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  if (!token.toString) {\n    return 'object';\n  }\n\n  // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\n\nexport interface Console {\n  log(message: string): void;\n  warn(message: string): void;\n}\n\nconst _global: {[name: string]: any} = globalThis;\nexport {_global as global};\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value!);\n  }\n  return list;\n}\n\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\nexport function partitionArray<T, F = T>(\n    arr: (T|F)[], conditionFn: (value: T|F) => boolean): [T[], F[]] {\n  const truthy: T[] = [];\n  const falsy: F[] = [];\n  for (const item of arr) {\n    (conditionFn(item) ? truthy : falsy).push(item as any);\n  }\n  return [truthy, falsy];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {utf8Encode} from '../util';\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION = 3;\n\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number,\n  sourceUrl?: string,\n  sourceLine0?: number,\n  sourceCol0?: number,\n};\n\nexport type SourceMap = {\n  version: number,\n  file?: string,\n      sourceRoot: string,\n      sources: string[],\n      sourcesContent: (string|null)[],\n      mappings: string,\n};\n\nexport class SourceMapGenerator {\n  private sourcesContent: Map<string, string|null> = new Map();\n  private lines: Segment[][] = [];\n  private lastCol0: number = 0;\n  private hasMappings = false;\n\n  constructor(private file: string|null = null) {}\n\n  // The content is `null` when the content is expected to be loaded using the URL\n  addSource(url: string, content: string|null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n\n  addLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n\n  addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get currentLine(): Segment[]|null {\n    return this.lines.slice(-1)[0];\n  }\n\n  toJSON(): SourceMap|null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const sourcesIndex = new Map<string, number>();\n    const sources: string[] = [];\n    const sourcesContent: (string|null)[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let mappings: string = '';\n    let lastCol0: number = 0;\n    let lastSourceIndex: number = 0;\n    let lastSourceLine0: number = 0;\n    let lastSourceCol0: number = 0;\n\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n\n      mappings += segments\n                      .map(segment => {\n                        // zero-based starting column of the line in the generated code\n                        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                        lastCol0 = segment.col0;\n\n                        if (segment.sourceUrl != null) {\n                          // zero-based index into the âsourcesâ list\n                          segAsStr +=\n                              toBase64VLQ(sourcesIndex.get(segment.sourceUrl)! - lastSourceIndex);\n                          lastSourceIndex = sourcesIndex.get(segment.sourceUrl)!;\n                          // the zero-based starting line in the original source\n                          segAsStr += toBase64VLQ(segment.sourceLine0! - lastSourceLine0);\n                          lastSourceLine0 = segment.sourceLine0!;\n                          // the zero-based starting column in the original source\n                          segAsStr += toBase64VLQ(segment.sourceCol0! - lastSourceCol0);\n                          lastSourceCol0 = segment.sourceCol0!;\n                        }\n\n                        return segAsStr;\n                      })\n                      .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n\n  toJsComment(): string {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n                              '';\n  }\n}\n\nexport function toBase64String(value: string): string {\n  let b64 = '';\n  const encoded = utf8Encode(value);\n  for (let i = 0; i < encoded.length;) {\n    const i1 = encoded[i++];\n    const i2 = i < encoded.length ? encoded[i++] : null;\n    const i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext {\n    return new EmitterVisitorContext(0);\n  }\n\n  private _lines: _EmittedLine[];\n\n  constructor(private _indent: number) {\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get _currentLine(): _EmittedLine {\n    return this._lines[this._lines.length - 1];\n  }\n\n  println(from?: {sourceSpan: ParseSourceSpan|null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean {\n    return this._currentLine.parts.length === 0;\n  }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan|null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx]!;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  protected printLeadingComments(stmt: o.Statement, ctx: EmitterVisitorContext): void {\n    if (stmt.leadingComments === undefined) {\n      return;\n    }\n    for (const comment of stmt.leadingComments) {\n      if (comment instanceof o.JSDocComment) {\n        ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\n      } else {\n        if (comment.multiline) {\n          ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\n        } else {\n          comment.text.split('\\n').forEach((line) => {\n            ctx.println(stmt, `// ${line}`);\n          });\n        }\n      }\n    }\n  }\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    this.printLeadingComments(stmt, ctx);\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitTaggedTemplateExpr(expr: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    expr.tag.visitExpression(this, ctx);\n    ctx.print(expr, '`' + expr.template.elements[0].rawText);\n    for (let i = 1; i < expr.template.elements.length; i++) {\n      ctx.print(expr, '${');\n      expr.template.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(expr, `}${expr.template.elements[i].rawText}`);\n    }\n    ctx.print(expr, '`');\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase!.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n\n  visitDynamicImportExpr(ast: o.DynamicImportExpr, ctx: EmitterVisitorContext) {\n    ctx.print(ast, `import(${ast.url})`);\n  }\n\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitUnaryOperatorExpr(ast: o.UnaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.UnaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.UnaryOperator.Minus:\n        opStr = '-';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ctx.print(ast, opStr);\n    ast.expr.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      case o.BinaryOperator.NullishCoalesce:\n        opStr = '??';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {escapeIdentifier} from '../output/abstract_emitter';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers} from './r3_identifiers';\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  if (numParams === 0) {\n    return o.expressionType(type);\n  }\n  const params: o.Type[] = [];\n  for (let i = 0; i < numParams; i++) {\n    params.push(o.DYNAMIC_TYPE);\n  }\n  return o.expressionType(type, undefined, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\n/**\n * Result of compilation of a render3 code unit, e.g. component, directive, pipe, etc.\n */\nexport interface R3CompiledExpression {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nconst ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function getSafePropertyAccessString(accessor: string, name: string): string {\n  const escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngJitMode', expr);\n}\n\nexport function devOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  return guardedExpression('ngDevMode', expr);\n}\n\nexport function guardedExpression(guard: string, expr: o.Expression): o.Expression {\n  const guardExpr = new o.ExternalExpr({name: guard, moduleName: null});\n  const guardNotDefined = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Identical, new o.TypeofExpr(guardExpr), o.literal('undefined'));\n  const guardUndefinedOrTrue = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined,\n      /* sourceSpan */ undefined, true);\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}\n\nexport function refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n}\n\n\n/**\n * Describes an expression that may have been wrapped in a `forwardRef()` guard.\n *\n * This is used when describing expressions that can refer to types that may eagerly reference types\n * that have not yet been defined.\n */\nexport interface MaybeForwardRefExpression<T extends o.Expression = o.Expression> {\n  /**\n   * The unwrapped expression.\n   */\n  expression: T;\n  /**\n   * Specified whether the `expression` contains a reference to something that has not yet been\n   * defined, and whether the expression is still wrapped in a `forwardRef()` call.\n   *\n   * If this value is `ForwardRefHandling.None` then the `expression` is safe to use as-is.\n   *\n   * Otherwise the `expression` was wrapped in a call to `forwardRef()` and must not be eagerly\n   * evaluated. Instead it must be wrapped in a function closure that will be evaluated lazily to\n   * allow the definition of the expression to be evaluated first.\n   *\n   * In full AOT compilation it can be safe to unwrap the `forwardRef()` call up front if the\n   * expression will actually be evaluated lazily inside a function call after the value of\n   * `expression` has been defined.\n   *\n   * But in other cases, such as partial AOT compilation or JIT compilation the expression will be\n   * evaluated eagerly in top level code so will need to continue to be wrapped in a `forwardRef()`\n   * call.\n   *\n   */\n  forwardRef: ForwardRefHandling;\n}\n\nexport function createMayBeForwardRefExpression<T extends o.Expression>(\n    expression: T, forwardRef: ForwardRefHandling): MaybeForwardRefExpression<T> {\n  return {expression, forwardRef};\n}\n\n/**\n * Convert a `MaybeForwardRefExpression` to an `Expression`, possibly wrapping its expression in a\n * `forwardRef()` call.\n *\n * If `MaybeForwardRefExpression.forwardRef` is `ForwardRefHandling.Unwrapped` then the expression\n * was originally wrapped in a `forwardRef()` call to prevent the value from being eagerly evaluated\n * in the code.\n *\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\n */\nexport function convertFromMaybeForwardRefExpression(\n    {expression, forwardRef}: MaybeForwardRefExpression): o.Expression {\n  switch (forwardRef) {\n    case ForwardRefHandling.None:\n    case ForwardRefHandling.Wrapped:\n      return expression;\n    case ForwardRefHandling.Unwrapped:\n      return generateForwardRef(expression);\n  }\n}\n\n/**\n * Generate an expression that has the given `expr` wrapped in the following form:\n *\n * ```\n * forwardRef(() => expr)\n * ```\n */\nexport function generateForwardRef(expr: o.Expression): o.Expression {\n  return o.importExpr(Identifiers.forwardRef).callFn([o.fn([], [new o.ReturnStatement(expr)])]);\n}\n\n/**\n * Specifies how a forward ref has been handled in a MaybeForwardRefExpression\n */\nexport const enum ForwardRefHandling {\n  /** The expression was not wrapped in a `forwardRef()` call in the first place. */\n  None,\n  /** The expression is still wrapped in a `forwardRef()` call. */\n  Wrapped,\n  /** The expression was wrapped in a `forwardRef()` call but has since been unwrapped. */\n  Unwrapped,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectFlags} from '../core';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\n\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class = 0,\n  Function = 1,\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata =\n    R3ConstructorFactoryMetadata|R3DelegatedFnOrClassMetadata|R3ExpressionFactoryMetadata;\n\nexport enum FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   * Or `null` if the dependency could not be resolved - making it invalid.\n   */\n  token: o.Expression|null;\n\n  /**\n   * If an @Attribute decorator is present, this is the literal type of the attribute name, or\n   * the unknown type if no literal type is available (e.g. the attribute name is an expression).\n   * Otherwise it is null;\n   */\n  attributeNameType: o.Expression|null;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3CompiledExpression {\n  const t = o.variable('t');\n  let baseFactoryVar: o.ReadVarExpr|null = null;\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\n      new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.type.value) :\n      t;\n\n  let ctorExpr: o.Expression|null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    baseFactoryVar = o.variable(`Éµ${meta.name}_BaseFactory`);\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression|null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('r');\n    body.push(r.set(o.NULL_EXPR).toDeclStmt());\n    const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\n                                         o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedFactoryMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n        meta.delegateType === R3FactoryDelegateType.Class ?\n            o.InstantiateExpr :\n            o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n\n  if (retExpr === null) {\n    // The expression cannot be formed so render an `ÉµÉµinvalidFactory()` call.\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    // This factory uses a base factory, so call `ÉµÉµgetInheritedFactory()` to compute it.\n    const getInheritedFactoryCall = o.importExpr(R3.getInheritedFactory).callFn([meta.type.value]);\n    // Memoize the base factoryFn: `baseFactory || (baseFactory = ÉµÉµgetInheritedFactory(...))`\n    const baseFactory = new o.BinaryOperatorExpr(\n        o.BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new o.ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    // This is straightforward factory, just return it.\n    body.push(new o.ReturnStatement(retExpr));\n  }\n\n  let factoryFn: o.Expression = o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)], body, o.INFERRED_TYPE, undefined,\n      `${meta.name}_Factory`);\n\n  if (baseFactoryVar !== null) {\n    // There is a base factory variable so wrap its declaration along with the factory function into\n    // an IIFE.\n    factoryFn = o.fn([], [\n                   new o.DeclareVarStmt(baseFactoryVar.name!), new o.ReturnStatement(factoryFn)\n                 ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\n  }\n\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta),\n  };\n}\n\nexport function createFactoryType(meta: R3FactoryMetadata) {\n  const ctorDepsType =\n      meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : o.NONE_TYPE;\n  return o.expressionType(o.importExpr(\n      R3.FactoryDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\n\nfunction injectDependencies(deps: R3DependencyMetadata[], target: FactoryTarget): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, target, index));\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, target: FactoryTarget, index: number): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  if (dep.token === null) {\n    return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    // Build up the injection flags according to the metadata.\n    const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n        (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n        (dep.optional ? InjectFlags.Optional : 0) |\n        (target === FactoryTarget.Pipe ? InjectFlags.ForPipe : 0);\n\n    // If this dependency is optional or otherwise has non-default flags, then additional\n    // parameters describing how to inject the dependency must be passed to the inject function\n    // that's being used.\n    let flagsParam: o.LiteralExpr|null =\n        (flags !== InjectFlags.Default || dep.optional) ? o.literal(flags) : null;\n\n    // Build up the arguments to the injectFn call.\n    const injectArgs = [dep.token];\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n    const injectFn = getInjectFn(target);\n    return o.importExpr(injectFn).callFn(injectArgs);\n  } else {\n    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n    // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n    // we want to generate `ÉµÉµinjectAttribute(foo())`.\n    //\n    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n    // typings.\n    return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n  }\n}\n\nfunction createCtorDepsType(deps: R3DependencyMetadata[]): o.Type {\n  let hasTypes = false;\n  const attributeTypes = deps.map(dep => {\n    const type = createCtorDepType(dep);\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return o.literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return o.expressionType(o.literalArr(attributeTypes));\n  } else {\n    return o.NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep: R3DependencyMetadata): o.LiteralMapExpr|null {\n  const entries: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  if (dep.attributeNameType !== null) {\n    entries.push({key: 'attribute', value: dep.attributeNameType, quoted: false});\n  }\n  if (dep.optional) {\n    entries.push({key: 'optional', value: o.literal(true), quoted: false});\n  }\n  if (dep.host) {\n    entries.push({key: 'host', value: o.literal(true), quoted: false});\n  }\n  if (dep.self) {\n    entries.push({key: 'self', value: o.literal(true), quoted: false});\n  }\n  if (dep.skipSelf) {\n    entries.push({key: 'skipSelf', value: o.literal(true), quoted: false});\n  }\n\n  return entries.length > 0 ? o.literalMap(entries) : null;\n}\n\nexport function isDelegatedFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nexport function isExpressionFactoryMetadata(meta: R3FactoryMetadata):\n    meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n\nfunction getInjectFn(target: FactoryTarget): o.ExternalReference {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return R3.directiveInject;\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return R3.inject;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {AST, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType} from '../expression_parser/ast';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit<Result>(visitor: Visitor<Result>): Result;\n}\n\n/**\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\n * require the implementation of a visitor for Comments as they are only collected at\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\n * is true.\n */\nexport class Comment implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(_visitor: Visitor<Result>): Result {\n    throw new Error('visit() not implemented for Comment');\n  }\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitText(this);\n  }\n}\n\nexport class BoundText implements Node {\n  constructor(public value: AST, public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundText(this);\n  }\n}\n\n/**\n * Represents a text attribute in the template.\n *\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\n */\nexport class TextAttribute implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan?: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTextAttribute(this);\n  }\n}\n\nexport class BoundAttribute implements Node {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: AST, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan: ParseSourceSpan|undefined,\n      public i18n: I18nMeta|undefined) {}\n\n  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta): BoundAttribute {\n    if (prop.keySpan === undefined) {\n      throw new Error(\n          `Unexpected state: keySpan must be defined for bound attributes but was not for ${\n              prop.name}: ${prop.sourceSpan}`);\n    }\n    return new BoundAttribute(\n        prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan,\n        prop.keySpan, prop.valueSpan, i18n);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundAttribute(this);\n  }\n}\n\nexport class BoundEvent implements Node {\n  constructor(\n      public name: string, public type: ParsedEventType, public handler: AST,\n      public target: string|null, public phase: string|null, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string|null =\n        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n    if (event.keySpan === undefined) {\n      throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${\n          event.name}: ${event.sourceSpan}`);\n    }\n    return new BoundEvent(\n        event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan,\n        event.keySpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitBoundEvent(this);\n  }\n}\n\nexport class Element implements Node {\n  constructor(\n      public name: string, public attributes: TextAttribute[], public inputs: BoundAttribute[],\n      public outputs: BoundEvent[], public children: Node[], public references: Reference[],\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitElement(this);\n  }\n}\n\nexport abstract class DeferredTrigger implements Node {\n  constructor(public sourceSpan: ParseSourceSpan) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredTrigger(this);\n  }\n}\n\nexport class BoundDeferredTrigger extends DeferredTrigger {\n  constructor(public value: AST, sourceSpan: ParseSourceSpan) {\n    super(sourceSpan);\n  }\n}\n\nexport class IdleDeferredTrigger extends DeferredTrigger {}\n\nexport class ImmediateDeferredTrigger extends DeferredTrigger {}\n\nexport class HoverDeferredTrigger extends DeferredTrigger {}\n\nexport class TimerDeferredTrigger extends DeferredTrigger {\n  constructor(public delay: number, sourceSpan: ParseSourceSpan) {\n    super(sourceSpan);\n  }\n}\n\nexport class InteractionDeferredTrigger extends DeferredTrigger {\n  constructor(public reference: string|null, sourceSpan: ParseSourceSpan) {\n    super(sourceSpan);\n  }\n}\n\nexport class ViewportDeferredTrigger extends DeferredTrigger {\n  constructor(public reference: string|null, sourceSpan: ParseSourceSpan) {\n    super(sourceSpan);\n  }\n}\n\nexport class DeferredBlockPlaceholder implements Node {\n  constructor(\n      public children: Node[], public minimumTime: number|null, public sourceSpan: ParseSourceSpan,\n      public startSourceSpan: ParseSourceSpan, public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlockPlaceholder(this);\n  }\n}\n\nexport class DeferredBlockLoading implements Node {\n  constructor(\n      public children: Node[], public afterTime: number|null, public minimumTime: number|null,\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlockLoading(this);\n  }\n}\n\nexport class DeferredBlockError implements Node {\n  constructor(\n      public children: Node[], public sourceSpan: ParseSourceSpan,\n      public startSourceSpan: ParseSourceSpan, public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlockError(this);\n  }\n}\n\nexport class DeferredBlock implements Node {\n  constructor(\n      public children: Node[], public triggers: DeferredTrigger[],\n      public prefetchTriggers: DeferredTrigger[], public placeholder: DeferredBlockPlaceholder|null,\n      public loading: DeferredBlockLoading|null, public error: DeferredBlockError|null,\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitDeferredBlock(this);\n  }\n}\n\nexport class Template implements Node {\n  constructor(\n      // tagName is the name of the container element, if applicable.\n      // `null` is a special case for when there is a structural directive on an `ng-template` so\n      // the renderer can differentiate between the synthetic template and the one written in the\n      // file.\n      public tagName: string|null,\n      public attributes: TextAttribute[],\n      public inputs: BoundAttribute[],\n      public outputs: BoundEvent[],\n      public templateAttrs: (BoundAttribute|TextAttribute)[],\n      public children: Node[],\n      public references: Reference[],\n      public variables: Variable[],\n      public sourceSpan: ParseSourceSpan,\n      public startSourceSpan: ParseSourceSpan,\n      public endSourceSpan: ParseSourceSpan|null,\n      public i18n?: I18nMeta,\n  ) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitTemplate(this);\n  }\n}\n\nexport class Content implements Node {\n  readonly name = 'ng-content';\n\n  constructor(\n      public selector: string, public attributes: TextAttribute[],\n      public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitContent(this);\n  }\n}\n\nexport class Variable implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitVariable(this);\n  }\n}\n\nexport class Reference implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitReference(this);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n      public vars: {[name: string]: BoundText},\n      public placeholders: {[name: string]: Text|BoundText}, public sourceSpan: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result {\n    return visitor.visitIcu(this);\n  }\n}\n\nexport interface Visitor<Result = any> {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node): Result;\n\n  visitElement(element: Element): Result;\n  visitTemplate(template: Template): Result;\n  visitContent(content: Content): Result;\n  visitVariable(variable: Variable): Result;\n  visitReference(reference: Reference): Result;\n  visitTextAttribute(attribute: TextAttribute): Result;\n  visitBoundAttribute(attribute: BoundAttribute): Result;\n  visitBoundEvent(attribute: BoundEvent): Result;\n  visitText(text: Text): Result;\n  visitBoundText(text: BoundText): Result;\n  visitIcu(icu: Icu): Result;\n  visitDeferredBlock(deferred: DeferredBlock): Result;\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder): Result;\n  visitDeferredBlockError(block: DeferredBlockError): Result;\n  visitDeferredBlockLoading(block: DeferredBlockLoading): Result;\n  visitDeferredTrigger(trigger: DeferredTrigger): Result;\n}\n\nexport class RecursiveVisitor implements Visitor<void> {\n  visitElement(element: Element): void {\n    visitAll(this, element.attributes);\n    visitAll(this, element.inputs);\n    visitAll(this, element.outputs);\n    visitAll(this, element.children);\n    visitAll(this, element.references);\n  }\n  visitTemplate(template: Template): void {\n    visitAll(this, template.attributes);\n    visitAll(this, template.inputs);\n    visitAll(this, template.outputs);\n    visitAll(this, template.children);\n    visitAll(this, template.references);\n    visitAll(this, template.variables);\n  }\n  visitDeferredBlock(deferred: DeferredBlock): void {\n    visitAll(this, deferred.triggers);\n    visitAll(this, deferred.prefetchTriggers);\n    visitAll(this, deferred.children);\n    deferred.placeholder?.visit(this);\n    deferred.loading?.visit(this);\n    deferred.error?.visit(this);\n  }\n  visitDeferredBlockPlaceholder(block: DeferredBlockPlaceholder): void {\n    visitAll(this, block.children);\n  }\n  visitDeferredBlockError(block: DeferredBlockError): void {\n    visitAll(this, block.children);\n  }\n  visitDeferredBlockLoading(block: DeferredBlockLoading): void {\n    visitAll(this, block.children);\n  }\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n  visitDeferredTrigger(trigger: DeferredTrigger): void {}\n}\n\n\nexport function visitAll<Result>(visitor: Visitor<Result>, nodes: Node[]): Result[] {\n  const result: Result[] = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      visitor.visit(node) || node.visit(visitor);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\n/**\n * Describes the text contents of a placeholder as it appears in an ICU expression, including its\n * source span information.\n */\nexport interface MessagePlaceholder {\n  /** The text contents of the placeholder */\n  text: string;\n\n  /** The source span of the placeholder */\n  sourceSpan: ParseSourceSpan;\n}\n\nexport class Message {\n  sources: MessageSpan[];\n  id: string;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n  legacyIds: string[] = [];\n\n  messageString: string;\n\n  /**\n   * @param nodes message AST\n   * @param placeholders maps placeholder names to static content and their source spans\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param customId\n   */\n  constructor(\n      public nodes: Node[], public placeholders: {[phName: string]: MessagePlaceholder},\n      public placeholderToMessage: {[phName: string]: Message}, public meaning: string,\n      public description: string, public customId: string) {\n    this.id = this.customId;\n    this.messageString = serializeMessage(this.nodes);\n\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitText(this, context);\n  }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitContainer(this, context);\n  }\n}\n\nexport class Icu implements Node {\n  constructor(\n      public expression: string, public type: string, public cases: {[k: string]: Node},\n      public sourceSpan: ParseSourceSpan, public expressionPlaceholder?: string) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcu(this, context);\n  }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n      public tag: string, public attrs: {[k: string]: string}, public startName: string,\n      public closeName: string, public children: Node[], public isVoid: boolean,\n      // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n      public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitTagPlaceholder(this, context);\n  }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitPlaceholder(this, context);\n  }\n}\n\nexport class IcuPlaceholder implements Node {\n  /** Used to capture a message computed from a previous processing pass (see `setI18nRefs()`). */\n  previousMessage?: Message;\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any {\n    return visitor.visitIcuPlaceholder(this, context);\n  }\n}\n\n/**\n * Each HTML node that is affect by an i18n tag will also have an `i18n` property that is of type\n * `I18nMeta`.\n * This information is either a `Message`, which indicates it is the root of an i18n message, or a\n * `Node`, which indicates is it part of a containing `Message`.\n */\nexport type I18nMeta = Message|Node;\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text {\n    return new Text(text.value, text.sourceSpan);\n  }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan, icu.expressionPlaceholder);\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(\n        ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan,\n        ph.startSourceSpan, ph.endSourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => {\n      icu.cases[k].visit(this);\n    });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n\n\n/**\n * Serialize the message to the Localize backtick string format that would appear in compiled code.\n */\nfunction serializeMessage(messageNodes: Node[]): string {\n  const visitor = new LocalizeMessageStringVisitor();\n  const str = messageNodes.map(n => n.visit(visitor)).join('');\n  return str;\n}\n\nclass LocalizeMessageStringVisitor implements Visitor {\n  visitText(text: Text): any {\n    return text.value;\n  }\n\n  visitContainer(container: Container): any {\n    return container.children.map(child => child.visit(this)).join('');\n  }\n\n  visitIcu(icu: Icu): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder): any {\n    const children = ph.children.map(child => child.visit(this)).join('');\n    return `{$${ph.startName}}${children}{$${ph.closeName}}`;\n  }\n\n  visitPlaceholder(ph: Placeholder): any {\n    return `{$${ph.name}}`;\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder): any {\n    return `{$${ph.name}}`;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../i18n_ast';\n\nexport abstract class Serializer {\n  // - The `placeholders` and `placeholderToMessage` properties are irrelevant in the input messages\n  // - The `id` contains the message id that the serializer is expected to use\n  // - Placeholder names are already map to public names using the provided mapper\n  abstract write(messages: i18n.Message[], locale: string|null): string;\n\n  abstract load(content: string, url: string):\n      {locale: string|null, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}};\n\n  abstract digest(message: i18n.Message): string;\n\n  // Creates a name mapper, see `PlaceholderMapper`\n  // Returning `null` means that no name mapping is used.\n  createNameMapper(message: i18n.Message): PlaceholderMapper|null {\n    return null;\n  }\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string|null;\n\n  toInternalName(publicName: string): string|null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string|null {\n    return this.internalToPublic.hasOwnProperty(internalName) ?\n        this.internalToPublic[internalName] :\n        null;\n  }\n\n  toInternalName(publicName: string): string|null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n                                                              null;\n  }\n\n  override visitText(text: i18n.Text, context?: any): any {\n    return null;\n  }\n\n  override visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  override visitPlaceholder(ph: i18n.Placeholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  override visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface IVisitor {\n  visitTag(tag: Tag): any;\n  visitText(text: Text): any;\n  visitDeclaration(decl: Declaration): any;\n  visitDoctype(doctype: Doctype): any;\n}\n\nclass _Visitor implements IVisitor {\n  visitTag(tag: Tag): string {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n\n  visitText(text: Text): string {\n    return text.value;\n  }\n\n  visitDeclaration(decl: Declaration): string {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n\n  private _serializeAttributes(attrs: {[k: string]: string}) {\n    const strAttrs = Object.keys(attrs).map((name: string) => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n\n  visitDoctype(doctype: Doctype): any {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n}\n\nconst _visitor = new _Visitor();\n\nexport function serialize(nodes: Node[]): string {\n  return nodes.map((node: Node): string => node.visit(_visitor)).join('');\n}\n\nexport interface Node {\n  visit(visitor: IVisitor): any;\n}\n\nexport class Declaration implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(unescapedAttrs: {[k: string]: string}) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDeclaration(this);\n  }\n}\n\nexport class Doctype implements Node {\n  constructor(public rootTag: string, public dtd: string) {}\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitDoctype(this);\n  }\n}\n\nexport class Tag implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(\n      public name: string, unescapedAttrs: {[k: string]: string} = {},\n      public children: Node[] = []) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitTag(this);\n  }\n}\n\nexport class Text implements Node {\n  value: string;\n  constructor(unescapedValue: string) {\n    this.value = escapeXml(unescapedValue);\n  }\n\n  visit(visitor: IVisitor): any {\n    return visitor.visitText(this);\n  }\n}\n\nexport class CR extends Text {\n  constructor(ws: number = 0) {\n    super(`\\n${new Array(ws + 1).join(' ')}`);\n  }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;'],\n];\n\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nexport function escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n      (text: string, entry: [RegExp, string]) => text.replace(entry[0], entry[1]), text);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG = 'source';\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class Xmb extends Serializer {\n  override write(messages: i18n.Message[], locale: string|null): string {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor();\n    let rootNode = new xml.Tag(_MESSAGES_TAG);\n\n    messages.forEach(message => {\n      const attrs: {[k: string]: string} = {id: message.id};\n\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n\n      let sourceTags: xml.Tag[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        sourceTags.push(new xml.Tag(\n            _SOURCE_TAG, {},\n            [new xml.Text(`${source.filePath}:${source.startLine}${\n                source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\n      });\n\n      rootNode.children.push(\n          new xml.CR(2),\n          new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n\n    rootNode.children.push(new xml.CR());\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n      new xml.CR(),\n      exampleVisitor.addDefaultExamples(rootNode),\n      new xml.CR(),\n    ]);\n  }\n\n  override load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    throw new Error('Unsupported');\n  }\n\n  override digest(message: i18n.Message): string {\n    return digest(message);\n  }\n\n\n  override createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nclass _Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] {\n    return [new xml.Text(text.value)];\n  }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startTagAsText = new xml.Text(`<${ph.tag}>`);\n    const startEx = new xml.Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const startTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeTagAsText = new xml.Text(`</${ph.tag}>`);\n    const closeEx = new xml.Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const closeTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx, closeTagAsText]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const interpolationAsText = new xml.Text(`{{${ph.value}}}`);\n    // Example tag needs to be not-empty for TC.\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, interpolationAsText])\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ');\n    const icuAsText = new xml.Text(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, icuAsText])\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new xml.Text(tag.attrs['name'] || '...');\n        tag.children = [new xml.Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitText(text: xml.Text): void {}\n  visitDeclaration(decl: xml.Declaration): void {}\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\nimport * as t from '../../r3_ast';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n\n/**\n * Prefix for non-`goog.getMsg` i18n-related vars.\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\n */\nexport const TRANSLATION_VAR_PREFIX = 'i18n_';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/** Placeholder wrapper for i18n expressions **/\nexport const I18N_PLACEHOLDER_SYMBOL = 'ï¿½';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): boolean {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\nexport function hasI18nMeta(node: t.Node&{i18n?: i18n.I18nMeta}): boolean {\n  return !!node.i18n;\n}\n\nexport function hasI18nAttrs(element: html.Element): boolean {\n  return element.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n}\n\nexport function icuFromI18nMessage(message: i18n.Message) {\n  return message.nodes[0] as i18n.IcuPlaceholder;\n}\n\nexport function wrapI18nPlaceholder(content: string|number, contextId: number = 0): string {\n  const blockId = contextId > 0 ? `:${contextId}` : '';\n  return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\n\nexport function assembleI18nBoundString(\n    strings: string[], bindingStartIndex: number = 0, contextId: number = 0): string {\n  if (!strings.length) return '';\n  let acc = '';\n  const lastIdx = strings.length - 1;\n  for (let i = 0; i < lastIdx; i++) {\n    acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n  }\n  acc += strings[lastIdx];\n  return acc;\n}\n\nexport function getSeqNumberGenerator(startsAt: number = 0): () => number {\n  let current = startsAt;\n  return () => current++;\n}\n\nexport function placeholdersToParams(placeholders: Map<string, string[]>):\n    {[name: string]: o.LiteralExpr} {\n  const params: {[name: string]: o.LiteralExpr} = {};\n  placeholders.forEach((values: string[], key: string) => {\n    params[key] = o.literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n  });\n  return params;\n}\n\nexport function updatePlaceholderMap(map: Map<string, any[]>, name: string, ...values: any[]) {\n  const current = map.get(name) || [];\n  current.push(...values);\n  map.set(name, current);\n}\n\nexport function assembleBoundTextPlaceholders(\n    meta: i18n.I18nMeta, bindingStartIndex: number = 0, contextId: number = 0): Map<string, any[]> {\n  const startIdx = bindingStartIndex;\n  const placeholders = new Map<string, any>();\n  const node =\n      meta instanceof i18n.Message ? meta.nodes.find(node => node instanceof i18n.Container) : meta;\n  if (node) {\n    (node as i18n.Container)\n        .children\n        .filter((child: i18n.Node): child is i18n.Placeholder => child instanceof i18n.Placeholder)\n        .forEach((child: i18n.Placeholder, idx: number) => {\n          const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n          updatePlaceholderMap(placeholders, child.name, content);\n        });\n  }\n  return placeholders;\n}\n\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nexport function formatI18nPlaceholderNamesInMap(\n    params: {[name: string]: o.Expression} = {}, useCamelCase: boolean) {\n  const _params: {[key: string]: o.Expression} = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(\n        key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\n\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nexport function formatI18nPlaceholderName(name: string, useCamelCase: boolean = true): string {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n  let postfix;\n  // eject last element if it's a number\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift()!.toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n      variable.name!, undefined, o.INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport {BindingType, Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {Identifiers as R3} from '../r3_identifiers';\nimport {ForwardRefHandling} from '../util';\n\nimport {R3QueryMetadata} from './api';\nimport {isI18nAttribute} from './i18n/util';\n\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/** The prefix reference variables */\nexport const REFERENCE_PREFIX = '_r';\n\n/** The name of the implicit context reference */\nexport const IMPLICIT_REFERENCE = '$implicit';\n\n/** Non bindable attribute name **/\nexport const NON_BINDABLE_ATTR = 'ngNonBindable';\n\n/** Name for the variable keeping track of the context returned by `ÉµÉµrestoreView`. */\nexport const RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n\n/**\n * Maximum length of a single instruction chain. Because our output AST uses recursion, we're\n * limited in how many expressions we can nest before we reach the call stack limit. This\n * length is set very conservatively in order to reduce the chance of problems.\n */\nconst MAX_CHAIN_LENGTH = 500;\n\n/** Instructions that support chaining. */\nconst CHAINABLE_INSTRUCTIONS = new Set([\n  R3.element,\n  R3.elementStart,\n  R3.elementEnd,\n  R3.elementContainer,\n  R3.elementContainerStart,\n  R3.elementContainerEnd,\n  R3.i18nExp,\n  R3.listener,\n  R3.classProp,\n  R3.syntheticHostListener,\n  R3.hostProperty,\n  R3.syntheticHostProperty,\n  R3.property,\n  R3.propertyInterpolate1,\n  R3.propertyInterpolate2,\n  R3.propertyInterpolate3,\n  R3.propertyInterpolate4,\n  R3.propertyInterpolate5,\n  R3.propertyInterpolate6,\n  R3.propertyInterpolate7,\n  R3.propertyInterpolate8,\n  R3.propertyInterpolateV,\n  R3.attribute,\n  R3.attributeInterpolate1,\n  R3.attributeInterpolate2,\n  R3.attributeInterpolate3,\n  R3.attributeInterpolate4,\n  R3.attributeInterpolate5,\n  R3.attributeInterpolate6,\n  R3.attributeInterpolate7,\n  R3.attributeInterpolate8,\n  R3.attributeInterpolateV,\n  R3.styleProp,\n  R3.stylePropInterpolate1,\n  R3.stylePropInterpolate2,\n  R3.stylePropInterpolate3,\n  R3.stylePropInterpolate4,\n  R3.stylePropInterpolate5,\n  R3.stylePropInterpolate6,\n  R3.stylePropInterpolate7,\n  R3.stylePropInterpolate8,\n  R3.stylePropInterpolateV,\n  R3.textInterpolate,\n  R3.textInterpolate1,\n  R3.textInterpolate2,\n  R3.textInterpolate3,\n  R3.textInterpolate4,\n  R3.textInterpolate5,\n  R3.textInterpolate6,\n  R3.textInterpolate7,\n  R3.textInterpolate8,\n  R3.textInterpolateV,\n]);\n\n/**\n * Possible types that can be used to generate the parameters of an instruction call.\n * If the parameters are a function, the function will be invoked at the time the instruction\n * is generated.\n */\nexport type InstructionParams = (o.Expression|o.Expression[])|(() => (o.Expression|o.Expression[]));\n\n/** Necessary information to generate a call to an instruction function. */\nexport interface Instruction {\n  span: ParseSourceSpan|null;\n  reference: o.ExternalReference;\n  paramsOrFn?: InstructionParams;\n}\n\n/** Generates a call to a single instruction. */\nexport function invokeInstruction(\n    span: ParseSourceSpan|null, reference: o.ExternalReference,\n    params: o.Expression[]): o.Expression {\n  return o.importExpr(reference, null, span).callFn(params, span);\n}\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr|null = null;\n  return () => {\n    if (!temp) {\n      statements.push(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression|o.Statement|t.Node): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\nexport function conditionallyCreateDirectiveBindingLiteral(\n    map: Record<string, string|{\n      classPropertyName: string;\n      bindingPropertyName: string;\n      transformFunction: o.Expression|null;\n    }>, keepDeclared?: boolean): o.Expression|null {\n  const keys = Object.getOwnPropertyNames(map);\n\n  if (keys.length === 0) {\n    return null;\n  }\n\n  return o.literalMap(keys.map(key => {\n    const value = map[key];\n    let declaredName: string;\n    let publicName: string;\n    let minifiedName: string;\n    let expressionValue: o.Expression;\n\n    if (typeof value === 'string') {\n      // canonical syntax: `dirProp: publicProp`\n      declaredName = key;\n      minifiedName = key;\n      publicName = value;\n      expressionValue = asLiteral(publicName);\n    } else {\n      minifiedName = key;\n      declaredName = value.classPropertyName;\n      publicName = value.bindingPropertyName;\n\n      if (keepDeclared && (publicName !== declaredName || value.transformFunction != null)) {\n        const expressionKeys = [asLiteral(publicName), asLiteral(declaredName)];\n\n        if (value.transformFunction != null) {\n          expressionKeys.push(value.transformFunction);\n        }\n\n        expressionValue = o.literalArr(expressionKeys);\n      } else {\n        expressionValue = asLiteral(publicName);\n      }\n    }\n\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: expressionValue,\n    };\n  }));\n}\n\n/**\n *  Remove trailing null nodes as they are implied.\n */\nexport function trimTrailingNulls(parameters: o.Expression[]): o.Expression[] {\n  while (o.isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n  return parameters;\n}\n\nexport function getQueryPredicate(\n    query: R3QueryMetadata, constantPool: ConstantPool): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map(token => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    // The original predicate may have been wrapped in a `forwardRef()` call.\n    switch (query.predicate.forwardRef) {\n      case ForwardRefHandling.None:\n      case ForwardRefHandling.Unwrapped:\n        return query.predicate.expression;\n      case ForwardRefHandling.Wrapped:\n        return o.importExpr(R3.resolveForwardRef).callFn([query.predicate.expression]);\n    }\n  }\n}\n\n/**\n * A representation for an object literal used during codegen of definition objects. The generic\n * type `T` allows to reference a documented type of the generated structure, such that the\n * property names that are set can be resolved to their documented declaration.\n */\nexport class DefinitionMap<T = any> {\n  values: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  set(key: keyof T, value: o.Expression|null): void {\n    if (value) {\n      this.values.push({key: key as string, value, quoted: false});\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr {\n    return o.literalMap(this.values);\n  }\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nexport function getAttrsForDirectiveMatching(elOrTpl: t.Element|\n                                             t.Template): {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach(i => {\n      if (i.type === BindingType.Property) {\n        attributesMap[i.name] = '';\n      }\n    });\n    elOrTpl.outputs.forEach(o => {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nexport function getInterpolationArgsLength(interpolation: Interpolation) {\n  const {expressions, strings} = interpolation;\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n\n/**\n * Generates the final instruction call statements based on the passed in configuration.\n * Will try to chain instructions as much as possible, if chaining is supported.\n */\nexport function getInstructionStatements(instructions: Instruction[]): o.Statement[] {\n  const statements: o.Statement[] = [];\n  let pendingExpression: o.Expression|null = null;\n  let pendingExpressionType: o.ExternalReference|null = null;\n  let chainLength = 0;\n\n  for (const current of instructions) {\n    const resolvedParams =\n        (typeof current.paramsOrFn === 'function' ? current.paramsOrFn() : current.paramsOrFn) ??\n        [];\n    const params = Array.isArray(resolvedParams) ? resolvedParams : [resolvedParams];\n\n    // If the current instruction is the same as the previous one\n    // and it can be chained, add another call to the chain.\n    if (chainLength < MAX_CHAIN_LENGTH && pendingExpressionType === current.reference &&\n        CHAINABLE_INSTRUCTIONS.has(pendingExpressionType)) {\n      // We'll always have a pending expression when there's a pending expression type.\n      pendingExpression = pendingExpression!.callFn(params, pendingExpression!.sourceSpan);\n      chainLength++;\n    } else {\n      if (pendingExpression !== null) {\n        statements.push(pendingExpression.toStmt());\n      }\n      pendingExpression = invokeInstruction(current.span, current.reference, params);\n      pendingExpressionType = current.reference;\n      chainLength = 0;\n    }\n  }\n\n  // Since the current instruction adds the previous one to the statements,\n  // we may be left with the final one at the end that is still pending.\n  if (pendingExpression !== null) {\n    statements.push(pendingExpression.toStmt());\n  }\n\n  return statements;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {compileFactoryFunction, FactoryTarget, R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata} from './render3/r3_factory';\nimport {Identifiers} from './render3/r3_identifiers';\nimport {convertFromMaybeForwardRefExpression, ForwardRefHandling, generateForwardRef, MaybeForwardRefExpression, R3CompiledExpression, R3Reference, typeWithParameters} from './render3/util';\nimport {DefinitionMap} from './render3/view/util';\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: R3Reference;\n  typeArgumentCount: number;\n  providedIn: MaybeForwardRefExpression;\n  useClass?: MaybeForwardRefExpression;\n  useFactory?: o.Expression;\n  useExisting?: MaybeForwardRefExpression;\n  useValue?: MaybeForwardRefExpression;\n  deps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(\n    meta: R3InjectableMetadata, resolveForwardRefs: boolean): R3CompiledExpression {\n  let result: {expression: o.Expression, statements: o.Statement[]}|null = null;\n\n  const factoryMeta: R3FactoryMetadata = {\n    name: meta.name,\n    type: meta.type,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n\n    const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.type.value);\n    let deps: R3DependencyMetadata[]|undefined = undefined;\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(\n            meta.type.value as o.WrappedNodeExpr<any>,\n            meta.useClass.expression as o.WrappedNodeExpr<any>, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function,\n      });\n    } else {\n      result = {\n        statements: [],\n        expression: o.fn([], [new o.ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue.expression,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting.expression]),\n    });\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(\n          meta.type.value as o.WrappedNodeExpr<any>, meta.type.value as o.WrappedNodeExpr<any>,\n          resolveForwardRefs)\n    };\n  }\n\n  const token = meta.type.value;\n\n  const injectableProps =\n      new DefinitionMap<{token: o.Expression, factory: o.Expression, providedIn: o.Expression}>();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression);\n\n  // Only generate providedIn property if it has a non-null value\n  if ((meta.providedIn.expression as o.LiteralExpr).value !== null) {\n    injectableProps.set('providedIn', convertFromMaybeForwardRefExpression(meta.providedIn));\n  }\n\n  const expression = o.importExpr(Identifiers.ÉµÉµdefineInjectable)\n                         .callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression,\n    type: createInjectableType(meta),\n    statements: result.statements,\n  };\n}\n\nexport function createInjectableType(meta: R3InjectableMetadata) {\n  return new o.ExpressionType(o.importExpr(\n      Identifiers.InjectableDeclaration,\n      [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\n\nfunction delegateToFactory(\n    type: o.WrappedNodeExpr<any>, useType: o.WrappedNodeExpr<any>,\n    unwrapForwardRefs: boolean): o.Expression {\n  if (type.node === useType.node) {\n    // The types are the same, so we can simply delegate directly to the type's factory.\n    // ```\n    // factory: type.Éµfac\n    // ```\n    return useType.prop('Éµfac');\n  }\n\n  if (!unwrapForwardRefs) {\n    // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n    // accepts a sub-type as an argument.\n    // ```\n    // factory: function(t) { return useType.Éµfac(t); }\n    // ```\n    return createFactoryFunction(useType);\n  }\n\n  // The useType is actually wrapped in a `forwardRef()` so we need to resolve that before\n  // calling its factory.\n  // ```\n  // factory: function(t) { return core.resolveForwardRef(type).Éµfac(t); }\n  // ```\n  const unwrappedType = o.importExpr(Identifiers.resolveForwardRef).callFn([useType]);\n  return createFactoryFunction(unwrappedType);\n}\n\nfunction createFactoryFunction(type: o.Expression): o.FunctionExpr {\n  return o.fn(\n      [new o.FnParam('t', o.DYNAMIC_TYPE)],\n      [new o.ReturnStatement(type.prop('Éµfac').callFn([o.variable('t')]))]);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n  /^\\s*$/,        // empty\n  /[<>]/,         // html tag\n  /^[{}]$/,       // i18n expansion\n  /&(#|[a-z])/i,  // character reference,\n  /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0] as string;\n    const end = value[1] as string;\n    // Check for unusable interpolation symbols\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from '../assertions';\n\nexport class InterpolationConfig {\n  static fromArray(markers: [string, string]|null): InterpolationConfig {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $BSPACE = 8;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $7 = 55;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $b = 98;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n\nexport function isNewLine(code: number): boolean {\n  return code === $LF || code === $CR;\n}\n\nexport function isOctalDigit(code: number): boolean {\n  return $0 <= code && code <= $7;\n}\n\nexport function isQuote(code: number): boolean {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from './chars';\nimport {stringify} from './util';\n\nexport class ParseLocation {\n  constructor(\n      public file: ParseSourceFile, public offset: number, public line: number,\n      public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine =\n            source.substring(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string, after: string}|null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url: string) {}\n}\n\nexport class ParseSourceSpan {\n  /**\n   * Create an object that holds information about spans of tokens/nodes captured during\n   * lexing/parsing of text.\n   *\n   * @param start\n   * The location of the start of the span (having skipped leading trivia).\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\n   * leading trivia, which could include newlines.\n   *\n   * @param end\n   * The location of the end of the span.\n   *\n   * @param fullStart\n   * The start of the token without skipping the leading trivia.\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\n   * incorrectly offset.\n   *\n   * @param details\n   * Additional information (such as identifier names) that should be associated with the span.\n   */\n  constructor(\n      public start: ParseLocation, public end: ParseLocation,\n      public fullStart: ParseLocation = start, public details: string|null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError {\n  constructor(\n      public span: ParseSourceSpan, public msg: string,\n      public level: ParseErrorLevel = ParseErrorLevel.ERROR) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n                 this.msg;\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n    kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\nlet _anonymousTypeIndex = 0;\n\nexport function identifierName(compileIdentifier: CompileIdentifierMetadata|null|undefined): string|\n    null {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  if (ref['__forward_ref__']) {\n    // We do not want to try to stringify a `forwardRef()` function because that would cause the\n    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n    return '__forward_ref__';\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\n\nexport interface CompileIdentifierMetadata {\n  reference: any;\n}\n\nexport function sanitizeIdentifier(name: string): string {\n  return name.replace(/\\W/g, '_');\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {AbstractEmitterVisitor, EmitterVisitorContext, escapeIdentifier} from './abstract_emitter';\nimport * as o from './output_ast';\n\n/**\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\n * be available in all environments.\n *\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\n * creates an inline helper with the same functionality.\n *\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\n * array.\n */\nconst makeTemplateObjectPolyfill =\n    '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\n\nexport abstract class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() {\n    super(false);\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  override visitTaggedTemplateExpr(ast: o.TaggedTemplateExpr, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // tag`...`\n    // ```\n    // which is effectively like:\n    // ```\n    // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    const elements = ast.template.elements;\n    ast.tag.visitExpression(this, ctx);\n    ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\n    ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\n    ast.template.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n  override visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  override visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // $localize `...`\n    // ```\n    // which is effectively like:\n    // ```\n    // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n\n  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @fileoverview\n * A module to facilitate use of a Trusted Types policy within the JIT\n * compiler. It lazily constructs the Trusted Types policy, providing helper\n * utilities for promoting strings to Trusted Types. When Trusted Types are not\n * available, strings are used as a fallback.\n * @security All use of this module is security-sensitive and should go through\n * security review.\n */\n\nimport {global} from '../util';\n\n/**\n * While Angular only uses Trusted Types internally for the time being,\n * references to Trusted Types could leak into our core.d.ts, which would force\n * anyone compiling against @angular/core to provide the @types/trusted-types\n * package in their compilation unit.\n *\n * Until https://github.com/microsoft/TypeScript/issues/30024 is resolved, we\n * will keep Angular's public API surface free of references to Trusted Types.\n * For internal and semi-private APIs that need to reference Trusted Types, the\n * minimal type definitions for the Trusted Types API provided by this module\n * should be used instead. They are marked as \"declare\" to prevent them from\n * being renamed by compiler optimization.\n *\n * Adapted from\n * https://github.com/DefinitelyTyped/DefinitelyTyped/blob/master/types/trusted-types/index.d.ts\n * but restricted to the API surface used within Angular.\n */\n\nexport declare interface TrustedScript {\n  __brand__: 'TrustedScript';\n}\n\nexport declare interface TrustedTypePolicyFactory {\n  createPolicy(policyName: string, policyOptions: {\n    createScript?: (input: string) => string,\n  }): TrustedTypePolicy;\n}\n\nexport declare interface TrustedTypePolicy {\n  createScript(input: string): TrustedScript;\n}\n\n\n/**\n * The Trusted Types policy, or null if Trusted Types are not\n * enabled/supported, or undefined if the policy has not been created yet.\n */\nlet policy: TrustedTypePolicy|null|undefined;\n\n/**\n * Returns the Trusted Types policy, or null if Trusted Types are not\n * enabled/supported. The first call to this function will create the policy.\n */\nfunction getPolicy(): TrustedTypePolicy|null {\n  if (policy === undefined) {\n    policy = null;\n    if (global.trustedTypes) {\n      try {\n        policy =\n            (global.trustedTypes as TrustedTypePolicyFactory).createPolicy('angular#unsafe-jit', {\n              createScript: (s: string) => s,\n            });\n      } catch {\n        // trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n  return policy;\n}\n\n/**\n * Unsafely promote a string to a TrustedScript, falling back to strings when\n * Trusted Types are not available.\n * @security In particular, it must be assured that the provided string will\n * never cause an XSS vulnerability if used in a context that will be\n * interpreted and executed as a script by a browser, e.g. when calling eval.\n */\nfunction trustedScriptFromString(script: string): TrustedScript|string {\n  return getPolicy()?.createScript(script) || script;\n}\n\n/**\n * Unsafely call the Function constructor with the given string arguments.\n * @security This is a security-sensitive function; any use of this function\n * must go through security review. In particular, it must be assured that it\n * is only called from the JIT compiler, as use in other code can lead to XSS\n * vulnerabilities.\n */\nexport function newTrustedFunctionForJIT(...args: string[]): Function {\n  if (!global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return new Function(...args);\n  }\n\n  // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n  const fnArgs = args.slice(0, -1).join(',');\n  const fnBody = args[args.length - 1];\n  const body = `(function anonymous(${fnArgs}\n) { ${fnBody}\n})`;\n\n  // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n  const fn = global['eval'](trustedScriptFromString(body) as string) as Function;\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return new Function(...args);\n  }\n\n  // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n  fn.toString = () => body;\n  // 2. When calling the resulting function, `this` should refer to `global`\n  return fn.bind(global);\n\n  // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {identifierName} from '../parse_util';\n\nimport {EmitterVisitorContext} from './abstract_emitter';\nimport {AbstractJsEmitterVisitor} from './abstract_js_emitter';\nimport * as o from './output_ast';\nimport {newTrustedFunctionForJIT} from './output_jit_trusted_types';\n\nexport interface ExternalReferenceResolver {\n  resolveExternalReference(ref: o.ExternalReference): unknown;\n}\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nexport class JitEvaluator {\n  /**\n   *\n   * @param sourceUrl The URL of the generated code.\n   * @param statements An array of Angular statement AST nodes to be evaluated.\n   * @param refResolver Resolves `o.ExternalReference`s into values.\n   * @param createSourceMaps If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns A map of all the variables in the generated code.\n   */\n  evaluateStatements(\n      sourceUrl: string, statements: o.Statement[], refResolver: ExternalReferenceResolver,\n      createSourceMaps: boolean): {[key: string]: any} {\n    const converter = new JitEmitterVisitor(refResolver);\n    const ctx = EmitterVisitorContext.createRoot();\n    // Ensure generated code is in strict mode\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [\n        o.literal('use strict').toStmt(),\n        ...statements,\n      ];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n\n  /**\n   * Evaluate a piece of JIT generated code.\n   * @param sourceUrl The URL of this generated code.\n   * @param ctx A context object that contains an AST of the code to be evaluated.\n   * @param vars A map containing the names and values of variables that the evaluated code might\n   * reference.\n   * @param createSourceMap If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns The result of evaluating the code.\n   */\n  evaluateCode(\n      sourceUrl: string, ctx: EmitterVisitorContext, vars: {[key: string]: any},\n      createSourceMap: boolean): any {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames: string[] = [];\n    const fnArgValues: any[] = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n      // E.g. ```\n      // function anonymous(a,b,c\n      // /**/) { ... }```\n      // We don't want to hard code this fact, so we auto detect it via an empty function first.\n      const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n\n  /**\n   * Execute a JIT generated function by calling it.\n   *\n   * This method can be overridden in tests to capture the functions that are generated\n   * by this `JitEvaluator` class.\n   *\n   * @param fn A function to execute.\n   * @param args The arguments to pass to the function being executed.\n   * @returns The return value of the executed function.\n   */\n  executeFunction(fn: Function, args: any[]) {\n    return fn(...args);\n  }\n}\n\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  private _evalArgNames: string[] = [];\n  private _evalArgValues: any[] = [];\n  private _evalExportedVars: string[] = [];\n\n  constructor(private refResolver: ExternalReferenceResolver) {\n    super();\n  }\n\n  createReturnStmt(ctx: EmitterVisitorContext) {\n    const stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(\n        resultVar => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n\n  getArgs(): {[key: string]: any} {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n\n  override visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, this.refResolver.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n\n  override visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n\n  override visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n\n  override visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n\n  private _emitReferenceToExternal(ast: o.Expression, value: any, ctx: EmitterVisitorContext):\n      void {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({reference: value}) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\n\n\nfunction isUseStrictStatement(statement: o.Statement): boolean {\n  return statement.isEquivalent(o.literal('use strict').toStmt());\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference} from './util';\nimport {DefinitionMap} from './view/util';\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: R3Reference;\n  providers: o.Expression|null;\n  imports: o.Expression[];\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3CompiledExpression {\n  const definitionMap = new DefinitionMap<{providers: o.Expression; imports: o.Expression;}>();\n\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', o.literalArr(meta.imports));\n  }\n\n  const expression =\n      o.importExpr(R3.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createInjectorType(meta);\n  return {expression, type, statements: []};\n}\n\nexport function createInjectorType(meta: R3InjectorMetadata): o.Type {\n  return new o.ExpressionType(\n      o.importExpr(R3.InjectorDeclaration, [new o.ExpressionType(meta.type.type)]));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\nimport {ExternalReferenceResolver} from '../output/output_jit';\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nexport class R3JitReflector implements ExternalReferenceResolver {\n  constructor(private context: {[key: string]: unknown}) {}\n\n  resolveExternalReference(ref: o.ExternalReference): unknown {\n    // This reflector only handles @angular/core imports.\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(`Cannot resolve external reference to ${\n          ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name!)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name!}'.`);\n    }\n    return this.context[ref.name!];\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {R3DeclareNgModuleFacade} from '../compiler_facade_interface';\nimport * as o from '../output/output_ast';\n\nimport {Identifiers as R3} from './r3_identifiers';\nimport {jitOnlyGuardedExpression, R3CompiledExpression, R3Reference, refsToArray} from './util';\nimport {DefinitionMap} from './view/util';\n\n/**\n * How the selector scope of an NgModule (its declarations, imports, and exports) should be emitted\n * as a part of the NgModule definition.\n */\nexport enum R3SelectorScopeMode {\n  /**\n   * Emit the declarations inline into the module definition.\n   *\n   * This option is useful in certain contexts where it's known that JIT support is required. The\n   * tradeoff here is that this emit style prevents directives and pipes from being tree-shaken if\n   * they are unused, but the NgModule is used.\n   */\n  Inline,\n\n  /**\n   * Emit the declarations using a side effectful function call, `ÉµÉµsetNgModuleScope`, that is\n   * guarded with the `ngJitMode` flag.\n   *\n   * This form of emit supports JIT and can be optimized away if the `ngJitMode` flag is set to\n   * false, which allows unused directives and pipes to be tree-shaken.\n   */\n  SideEffect,\n\n  /**\n   * Don't generate selector scopes at all.\n   *\n   * This is useful for contexts where JIT support is known to be unnecessary.\n   */\n  Omit,\n}\n\n/**\n * The type of the NgModule meta data.\n * - Global: Used for full and partial compilation modes which mainly includes R3References.\n * - Local: Used for the local compilation mode which mainly includes the raw expressions as appears\n * in the NgModule decorator.\n */\nexport enum R3NgModuleMetadataKind {\n  Global,\n  Local,\n}\n\ninterface R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind;\n\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * How to emit the selector scope values (declarations, imports, exports).\n   */\n  selectorScopeMode: R3SelectorScopeMode;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[]|null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression|null;\n}\n\n/**\n * Metadata required by the module compiler in full/partial mode to generate a module def (`Éµmod`)\n * for a type.\n */\nexport interface R3NgModuleMetadataGlobal extends R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind.Global;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * Those declarations which should be visible to downstream consumers. If not specified, all\n   * declarations are made visible to downstream consumers.\n   */\n  publicDeclarationTypes: o.Expression[]|null;\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * Whether or not to include `imports` in generated type declarations.\n   */\n  includeImportTypes: boolean;\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n}\n\n/**\n * Metadata required by the module compiler in local mode to generate a module def (`Éµmod`) for a\n * type.\n */\nexport interface R3NgModuleMetadataLocal extends R3NgModuleMetadataCommon {\n  kind: R3NgModuleMetadataKind.Local;\n\n  /**\n   * The output expression representing the bootstrap components specified by the module.\n   */\n  bootstrapExpression: o.Expression|null;\n\n  /**\n   * The output expression representing the declarations of the module.\n   */\n  declarationsExpression: o.Expression|null;\n\n  /**\n   * The output expression representing the imports of the module.\n   */\n  importsExpression: o.Expression|null;\n\n  /**\n   * The output expression representing the exports of the module.\n   */\n  exportsExpression: o.Expression|null;\n\n  /**\n   * Local compilation mode always requires scope to be handled using side effect function calls.\n   */\n  selectorScopeMode: R3SelectorScopeMode.SideEffect;\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`Éµmod`) for a type.\n */\nexport type R3NgModuleMetadata = R3NgModuleMetadataGlobal|R3NgModuleMetadataLocal;\n\n/**\n * The shape of the object literal that is passed to the `ÉµÉµdefineNgModule()` call.\n */\ninterface R3NgModuleDefMap {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the bootstrap components\n   * specified by the module.\n   */\n  bootstrap?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the directives and pipes\n   * declared by the module.\n   */\n  declarations?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the imports of the module.\n   */\n  imports?: o.Expression;\n  /**\n   * An expression evaluating to an array of expressions representing the exports of the module.\n   */\n  exports?: o.Expression;\n  /**\n   * A literal array expression containing the schemas that declare elements to be allowed in the\n   * NgModule.\n   */\n  schemas?: o.LiteralArrayExpr;\n  /**\n   * An expression evaluating to the unique ID of an NgModule.\n   * */\n  id?: o.Expression;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3CompiledExpression {\n  const statements: o.Statement[] = [];\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', meta.type.value);\n\n  // Assign bootstrap definition\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.bootstrap.length > 0) {\n      definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.bootstrapExpression) {\n      definitionMap.set('bootstrap', meta.bootstrapExpression);\n    }\n  }\n\n  if (meta.selectorScopeMode === R3SelectorScopeMode.Inline) {\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and\n    // `exports` to the `ÉµÉµdefineNgModule()` call directly.\n\n    if (meta.declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n\n    if (meta.imports.length > 0) {\n      definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n\n    if (meta.exports.length > 0) {\n      definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else if (meta.selectorScopeMode === R3SelectorScopeMode.SideEffect) {\n    // In this mode, scope information is not passed into `ÉµÉµdefineNgModule` as it\n    // would prevent tree-shaking of the declarations, imports and exports references. Instead, it's\n    // patched onto the NgModule definition with a `ÉµÉµsetNgModuleScope` call that's guarded by the\n    // `ngJitMode` flag.\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      statements.push(setNgModuleScopeCall);\n    }\n  } else {\n    // Selector scope emit was not requested, so skip it.\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', o.literalArr(meta.schemas.map(ref => ref.value)));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n\n    // Generate a side-effectful call to register this NgModule by its id, as per the semantics of\n    // NgModule ids.\n    statements.push(\n        o.importExpr(R3.registerNgModuleType).callFn([meta.type.value, meta.id]).toStmt());\n  }\n\n  const expression =\n      o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  const type = createNgModuleType(meta);\n\n  return {expression, type, statements};\n}\n\n/**\n * This function is used in JIT mode to generate the call to `ÉµÉµdefineNgModule()` from a call to\n * `ÉµÉµngDeclareNgModule()`.\n */\nexport function compileNgModuleDeclarationExpression(meta: R3DeclareNgModuleFacade): o.Expression {\n  const definitionMap = new DefinitionMap<R3NgModuleDefMap>();\n  definitionMap.set('type', new o.WrappedNodeExpr(meta.type));\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new o.WrappedNodeExpr(meta.bootstrap));\n  }\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new o.WrappedNodeExpr(meta.declarations));\n  }\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new o.WrappedNodeExpr(meta.imports));\n  }\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new o.WrappedNodeExpr(meta.exports));\n  }\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new o.WrappedNodeExpr(meta.schemas));\n  }\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new o.WrappedNodeExpr(meta.id));\n  }\n  return o.importExpr(R3.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nexport function createNgModuleType(meta: R3NgModuleMetadata): o.ExpressionType {\n  if (meta.kind === R3NgModuleMetadataKind.Local) {\n    return new o.ExpressionType(meta.type.value);\n  }\n\n  const {\n    type: moduleType,\n    declarations,\n    exports,\n    imports,\n    includeImportTypes,\n    publicDeclarationTypes\n  } = meta;\n\n  return new o.ExpressionType(o.importExpr(R3.NgModuleDeclaration, [\n    new o.ExpressionType(moduleType.type),\n    publicDeclarationTypes === null ? tupleTypeOf(declarations) :\n                                      tupleOfTypes(publicDeclarationTypes),\n    includeImportTypes ? tupleTypeOf(imports) : o.NONE_TYPE,\n    tupleTypeOf(exports),\n  ]));\n}\n\n/**\n * Generates a function call to `ÉµÉµsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n  const scopeMap = new DefinitionMap<\n      {declarations: o.Expression, imports: o.Expression, exports: o.Expression}>();\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.declarations.length > 0) {\n      scopeMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.declarationsExpression) {\n      scopeMap.set('declarations', meta.declarationsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.imports.length > 0) {\n      scopeMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.importsExpression) {\n      scopeMap.set('imports', meta.importsExpression);\n    }\n  }\n\n  if (meta.kind === R3NgModuleMetadataKind.Global) {\n    if (meta.exports.length > 0) {\n      scopeMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n    }\n  } else {\n    if (meta.exportsExpression) {\n      scopeMap.set('exports', meta.exportsExpression);\n    }\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n      /* fn */ o.importExpr(R3.setNgModuleScope),\n      /* args */[meta.type.value, scopeMap.toLiteralMap()]);\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(\n      /* params */[],\n      /* statements */[guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(\n      /* fn */ iife,\n      /* args */[]);\n\n  return iifeCall.toStmt();\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map(ref => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n\nfunction tupleOfTypes(types: o.Expression[]): o.Type {\n  const typeofTypes = types.map(type => o.typeofExpr(type));\n  return types.length > 0 ? o.expressionType(o.literalArr(typeofTypes)) : o.NONE_TYPE;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as o from '../output/output_ast';\n\nimport {R3DependencyMetadata} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3CompiledExpression, R3Reference, typeWithParameters} from './util';\n\nexport interface R3PipeMetadata {\n  /**\n   * Name of the pipe type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the pipe itself.\n   */\n  type: R3Reference;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * Name of the pipe.\n   */\n  pipeName: string;\n\n  /**\n   * Dependencies of the pipe's constructor.\n   */\n  deps: R3DependencyMetadata[]|null;\n\n  /**\n   * Whether the pipe is marked as pure.\n   */\n  pure: boolean;\n\n  /**\n   * Whether the pipe is standalone.\n   */\n  isStandalone: boolean;\n}\n\nexport function compilePipeFromMetadata(metadata: R3PipeMetadata): R3CompiledExpression {\n  const definitionMapValues: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  // e.g. `name: 'myPipe'`\n  definitionMapValues.push({key: 'name', value: o.literal(metadata.pipeName), quoted: false});\n\n  // e.g. `type: MyPipe`\n  definitionMapValues.push({key: 'type', value: metadata.type.value, quoted: false});\n\n  // e.g. `pure: true`\n  definitionMapValues.push({key: 'pure', value: o.literal(metadata.pure), quoted: false});\n\n  if (metadata.isStandalone) {\n    definitionMapValues.push({key: 'standalone', value: o.literal(true), quoted: false});\n  }\n\n  const expression =\n      o.importExpr(R3.definePipe).callFn([o.literalMap(definitionMapValues)], undefined, true);\n  const type = createPipeType(metadata);\n\n  return {expression, type, statements: []};\n}\n\nexport function createPipeType(metadata: R3PipeMetadata): o.Type {\n  return new o.ExpressionType(o.importExpr(R3.PipeDeclaration, [\n    typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n    new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n    new o.ExpressionType(new o.LiteralExpr(metadata.isStandalone)),\n  ]));\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy, ViewEncapsulation} from '../../core';\nimport {InterpolationConfig} from '../../ml_parser/interpolation_config';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport * as t from '../r3_ast';\nimport {R3DependencyMetadata} from '../r3_factory';\nimport {MaybeForwardRefExpression, R3Reference} from '../util';\n\n\n/**\n * Information needed to compile a directive for the render3 runtime.\n */\nexport interface R3DirectiveMetadata {\n  /**\n   * Name of the directive type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the directive itself.\n   */\n  type: R3Reference;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * A source span for the directive type.\n   */\n  typeSourceSpan: ParseSourceSpan;\n\n  /**\n   * Dependencies of the directive's constructor.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * Unparsed selector of the directive, or `null` if there was no selector.\n   */\n  selector: string|null;\n\n  /**\n   * Information about the content queries made by the directive.\n   */\n  queries: R3QueryMetadata[];\n\n  /**\n   * Information about the view queries made by the directive.\n   */\n  viewQueries: R3QueryMetadata[];\n\n  /**\n   * Mappings indicating how the directive interacts with its host element (host bindings,\n   * listeners, etc).\n   */\n  host: R3HostMetadata;\n\n  /**\n   * Information about usage of specific lifecycle events which require special treatment in the\n   * code generator.\n   */\n  lifecycle: {\n    /**\n     * Whether the directive uses NgOnChanges.\n     */\n    usesOnChanges: boolean;\n  };\n\n  /**\n   * A mapping of inputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  inputs: {[field: string]: R3InputMetadata};\n\n  /**\n   * A mapping of outputs from class property names to binding property names, or to a tuple of\n   * binding property name and class property name if the names are different.\n   */\n  outputs: {[field: string]: string};\n\n  /**\n   * Whether or not the component or directive inherits from another class\n   */\n  usesInheritance: boolean;\n\n  /**\n   * Whether or not the component or directive inherits its entire decorator from its base class.\n   */\n  fullInheritance: boolean;\n\n  /**\n   * Reference name under which to export the directive's type in a template,\n   * if any.\n   */\n  exportAs: string[]|null;\n\n  /**\n   * The list of providers defined in the directive.\n   */\n  providers: o.Expression|null;\n\n  /**\n   * Whether or not the component or directive is standalone.\n   */\n  isStandalone: boolean;\n\n  /**\n   * Whether or not the component or directive is signal-based.\n   */\n  isSignal: boolean;\n\n  /**\n   * Additional directives applied to the directive host.\n   */\n  hostDirectives: R3HostDirectiveMetadata[]|null;\n}\n\n/**\n * Specifies how a list of declaration type references should be emitted into the generated code.\n */\nexport const enum DeclarationListEmitMode {\n  /**\n   * The list of declarations is emitted into the generated code as is.\n   *\n   * ```\n   * directives: [MyDir],\n   * ```\n   */\n  Direct,\n\n  /**\n   * The list of declarations is emitted into the generated code wrapped inside a closure, which\n   * is needed when at least one declaration is a forward reference.\n   *\n   * ```\n   * directives: function () { return [MyDir, ForwardDir]; },\n   * ```\n   */\n  Closure,\n\n  /**\n   * Similar to `Closure`, with the addition that the list of declarations can contain individual\n   * items that are themselves forward references. This is relevant for JIT compilations, as\n   * unwrapping the forwardRef cannot be done statically so must be deferred. This mode emits\n   * the declaration list using a mapping transform through `resolveForwardRef` to ensure that\n   * any forward references within the list are resolved when the outer closure is invoked.\n   *\n   * Consider the case where the runtime has captured two declarations in two distinct values:\n   * ```\n   * const dirA = MyDir;\n   * const dirB = forwardRef(function() { return ForwardRef; });\n   * ```\n   *\n   * This mode would emit the declarations captured in `dirA` and `dirB` as follows:\n   * ```\n   * directives: function () { return [dirA, dirB].map(ng.resolveForwardRef); },\n   * ```\n   */\n  ClosureResolved,\n}\n\n/**\n * Describes a dependency used within a `{#defer}` block.\n */\nexport interface DeferBlockTemplateDependency {\n  /**\n   * Reference to a dependency.\n   */\n  type: o.WrappedNodeExpr<unknown>;\n\n  /**\n   * Dependency class name.\n   */\n  symbolName: string;\n\n  /**\n   * Whether this dependency can be defer-loaded.\n   */\n  isDeferrable: boolean;\n\n  /**\n   * Import path where this dependency is located.\n   */\n  importPath: string|null;\n}\n\n/**\n * Information needed to compile a component for the render3 runtime.\n */\nexport interface R3ComponentMetadata<DeclarationT extends R3TemplateDependency> extends\n    R3DirectiveMetadata {\n  /**\n   * Information about the component's template.\n   */\n  template: {\n    /**\n     * Parsed nodes of the template.\n     */\n    nodes: t.Node[];\n\n    /**\n     * Any ng-content selectors extracted from the template. Contains `*` when an ng-content\n     * element without selector is present.\n     */\n    ngContentSelectors: string[];\n  };\n\n  declarations: DeclarationT[];\n\n  /**\n   * Map of all types that can be defer loaded (ts.ClassDeclaration) ->\n   * corresponding import declaration (ts.ImportDeclaration) within\n   * the current source file.\n   */\n  deferrableDeclToImportDecl: Map<o.Expression, o.Expression>;\n\n  /**\n   * Map of {#defer} blocks -> their corresponding dependencies.\n   */\n  deferBlocks: Map<t.DeferredBlock, Array<DeferBlockTemplateDependency>>;\n\n  /**\n   * Specifies how the 'directives' and/or `pipes` array, if generated, need to be emitted.\n   */\n  declarationListEmitMode: DeclarationListEmitMode;\n\n  /**\n   * A collection of styling data that will be applied and scoped to the component.\n   */\n  styles: string[];\n\n  /**\n   * An encapsulation policy for the component's styling.\n   * Possible values:\n   * - `ViewEncapsulation.Emulated`: Apply modified component styles in order to emulate\n   *                                 a native Shadow DOM CSS encapsulation behavior.\n   * - `ViewEncapsulation.None`: Apply component styles globally without any sort of encapsulation.\n   * - `ViewEncapsulation.ShadowDom`: Use the browser's native Shadow DOM API to encapsulate styles.\n   */\n  encapsulation: ViewEncapsulation;\n\n  /**\n   * A collection of animation triggers that will be used in the component template.\n   */\n  animations: o.Expression|null;\n\n  /**\n   * The list of view providers defined in the component.\n   */\n  viewProviders: o.Expression|null;\n\n  /**\n   * Path to the .ts file in which this template's generated code will be included, relative to\n   * the compilation root. This will be used to generate identifiers that need to be globally\n   * unique in certain contexts (such as g3).\n   */\n  relativeContextFilePath: string;\n\n  /**\n   * Whether translation variable name should contain external message id\n   * (used by Closure Compiler's output of `goog.getMsg` for transition period).\n   */\n  i18nUseExternalIds: boolean;\n\n  /**\n   * Overrides the default interpolation start and end delimiters ({{ and }}).\n   */\n  interpolation: InterpolationConfig;\n\n  /**\n   * Strategy used for detecting changes in the component.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n}\n\n/**\n * Metadata for an individual input on a directive.\n */\nexport interface R3InputMetadata {\n  classPropertyName: string;\n  bindingPropertyName: string;\n  required: boolean;\n  transformFunction: o.Expression|null;\n}\n\nexport enum R3TemplateDependencyKind {\n  Directive = 0,\n  Pipe = 1,\n  NgModule = 2,\n}\n\n/**\n * A dependency that's used within a component template.\n */\nexport interface R3TemplateDependency {\n  kind: R3TemplateDependencyKind;\n\n  /**\n   * The type of the dependency as an expression.\n   */\n  type: o.Expression;\n}\n\n/**\n * A dependency that's used within a component template\n */\nexport type R3TemplateDependencyMetadata =\n    R3DirectiveDependencyMetadata|R3PipeDependencyMetadata|R3NgModuleDependencyMetadata;\n\n/**\n * Information about a directive that is used in a component template. Only the stable, public\n * facing information of the directive is stored here.\n */\nexport interface R3DirectiveDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Directive;\n\n  /**\n   * The selector of the directive.\n   */\n  selector: string;\n\n  /**\n   * The binding property names of the inputs of the directive.\n   */\n  inputs: string[];\n\n  /**\n   * The binding property names of the outputs of the directive.\n   */\n  outputs: string[];\n\n  /**\n   * Name under which the directive is exported, if any (exportAs in Angular). Null otherwise.\n   */\n  exportAs: string[]|null;\n\n  /**\n   * If true then this directive is actually a component; otherwise it is not.\n   */\n  isComponent: boolean;\n}\n\nexport interface R3PipeDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.Pipe;\n\n  name: string;\n}\n\nexport interface R3NgModuleDependencyMetadata extends R3TemplateDependency {\n  kind: R3TemplateDependencyKind.NgModule;\n}\n\n/**\n * Information needed to compile a query (view or content).\n */\nexport interface R3QueryMetadata {\n  /**\n   * Name of the property on the class to update with query results.\n   */\n  propertyName: string;\n\n  /**\n   * Whether to read only the first matching result, or an array of results.\n   */\n  first: boolean;\n\n  /**\n   * Either an expression representing a type or `InjectionToken` for the query\n   * predicate, or a set of string selectors.\n   */\n  predicate: MaybeForwardRefExpression|string[];\n\n  /**\n   * Whether to include only direct children or all descendants.\n   */\n  descendants: boolean;\n\n  /**\n   * If the `QueryList` should fire change event only if actual change to query was computed (vs old\n   * behavior where the change was fired whenever the query was recomputed, even if the recomputed\n   * query resulted in the same list.)\n   */\n  emitDistinctChangesOnly: boolean;\n\n  /**\n   * An expression representing a type to read from each matched node, or null if the default value\n   * for a given node is to be returned.\n   */\n  read: o.Expression|null;\n\n  /**\n   * Whether or not this query should collect only static results.\n   *\n   * If static is true, the query's results will be set on the component after nodes are created,\n   * but before change detection runs. This means that any results that relied upon change detection\n   * to run (e.g. results inside *ngIf or *ngFor views) will not be collected. Query results are\n   * available in the ngOnInit hook.\n   *\n   * If static is false, the query's results will be set on the component after change detection\n   * runs. This means that the query results can contain nodes inside *ngIf or *ngFor views, but\n   * the results will not be available in the ngOnInit hook (only in the ngAfterContentInit for\n   * content hooks and ngAfterViewInit for view hooks).\n   */\n  static: boolean;\n}\n\n/**\n * Mappings indicating how the class interacts with its\n * host element (host bindings, listeners, etc).\n */\nexport interface R3HostMetadata {\n  /**\n   * A mapping of attribute binding keys to `o.Expression`s.\n   */\n  attributes: {[key: string]: o.Expression};\n\n  /**\n   * A mapping of event binding keys to unparsed expressions.\n   */\n  listeners: {[key: string]: string};\n\n  /**\n   * A mapping of property binding keys to unparsed expressions.\n   */\n  properties: {[key: string]: string};\n\n  specialAttributes: {styleAttr?: string; classAttr?: string;};\n}\n\n/**\n * Information needed to compile a host directive for the render3 runtime.\n */\nexport interface R3HostDirectiveMetadata {\n  /** An expression representing the host directive class itself. */\n  directive: R3Reference;\n\n  /** Whether the expression referring to the host directive is a forward reference. */\n  isForwardReference: boolean;\n\n  /** Inputs from the host directive that will be exposed on the host. */\n  inputs: {[publicName: string]: string}|null;\n\n  /** Outputs from the host directive that will be exposed on the host. */\n  outputs: {[publicName: string]: string}|null;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class ParserError {\n  public message: string;\n  constructor(\n      message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport abstract class AST {\n  constructor(\n      public span: ParseSpan,\n      /**\n       * Absolute location of the expression AST in a source code file.\n       */\n      public sourceSpan: AbsoluteSourceSpan) {}\n\n  abstract visit(visitor: AstVisitor, context?: any): any;\n\n  toString(): string {\n    return 'AST';\n  }\n}\n\nexport abstract class ASTWithName extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n}\n\nexport class EmptyExpr extends AST {\n  override visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\n */\nexport class ThisReceiver extends ImplicitReceiver {\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitThisReceiver?.(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitChain(this, context);\n  }\n}\n\nexport class Conditional extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public condition: AST, public trueExp: AST,\n      public falseExp: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string, public value: AST) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, nameSpan: AbsoluteSourceSpan,\n      public receiver: AST, public name: string) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class SafeKeyedRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public key: AST,\n      public value: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends ASTWithName {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public exp: AST, public name: string,\n      public args: any[], nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan, nameSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPipe(this, context);\n  }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public value: any) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string; quoted: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public keys: LiteralMapKey[],\n      public values: any[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public strings: string[],\n      public expressions: AST[]) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operation: string, public left: AST,\n      public right: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\n/**\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\n * node that was originally used. This inheritance relation can be deleted in some future major,\n * after consumers have been given a chance to fully support Unary.\n */\nexport class Unary extends Binary {\n  // Redeclare the properties that are inherited from `Binary` as `never`, as consumers should not\n  // depend on these fields when operating on `Unary`.\n  override left: never = null as never;\n  override right: never = null as never;\n  override operation: never = null as never;\n\n  /**\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\n   */\n  static createMinus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n  }\n\n  /**\n   * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\n   */\n  static createPlus(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, expr: AST): Unary {\n    return new Unary(\n        span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n  }\n\n  /**\n   * During the deprecation period this constructor is private, to avoid consumers from creating\n   * a `Unary` with the fallback properties for `Binary`.\n   */\n  private constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operator: string, public expr: AST,\n      binaryOp: string, binaryLeft: AST, binaryRight: AST) {\n    super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n  }\n\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitUnary !== undefined) {\n      return visitor.visitUnary(this, context);\n    }\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class Call extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitCall(this, context);\n  }\n}\n\nexport class SafeCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public args: AST[],\n      public argumentSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeCall(this, context);\n  }\n}\n\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(public readonly start: number, public readonly end: number) {}\n}\n\nexport class ASTWithSource extends AST {\n  constructor(\n      public ast: AST, public source: string|null, public location: string, absoluteOffset: number,\n      public errors: ParserError[]) {\n    super(\n        new ParseSpan(0, source === null ? 0 : source.length),\n        new AbsoluteSourceSpan(\n            absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n  }\n  override visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  override toString(): string {\n    return `${this.source} in ${this.location}`;\n  }\n}\n\n/**\n * TemplateBinding refers to a particular key-value pair in a microsyntax\n * expression. A few examples are:\n *\n *   |---------------------|--------------|---------|--------------|\n *   |     expression      |     key      |  value  | binding type |\n *   |---------------------|--------------|---------|--------------|\n *   | 1. let item         |    item      |  null   |   variable   |\n *   | 2. of items         |   ngForOf    |  items  |  expression  |\n *   | 3. let x = y        |      x       |    y    |   variable   |\n *   | 4. index as i       |      i       |  index  |   variable   |\n *   | 5. trackBy: func    | ngForTrackBy |   func  |  expression  |\n *   | 6. *ngIf=\"cond\"     |     ngIf     |   cond  |  expression  |\n *   |---------------------|--------------|---------|--------------|\n *\n * (6) is a notable exception because it is a binding from the template key in\n * the LHS of a HTML attribute to the expression in the RHS. All other bindings\n * in the example above are derived solely from the RHS.\n */\nexport type TemplateBinding = VariableBinding|ExpressionBinding;\n\nexport class VariableBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key name of the LHS along with its span.\n   * @param value optional value for the RHS along with its span.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier,\n      public readonly value: TemplateBindingIdentifier|null) {}\n}\n\nexport class ExpressionBinding {\n  /**\n   * @param sourceSpan entire span of the binding.\n   * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n   * span. Note that the length of the span may not be the same as\n   * `key.source.length`. For example,\n   * 1. key.source = ngFor, key.span is for \"ngFor\"\n   * 2. key.source = ngForOf, key.span is for \"of\"\n   * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n   * @param value optional expression for the RHS.\n   */\n  constructor(\n      public readonly sourceSpan: AbsoluteSourceSpan,\n      public readonly key: TemplateBindingIdentifier, public readonly value: ASTWithSource|null) {}\n}\n\nexport interface TemplateBindingIdentifier {\n  source: string;\n  span: AbsoluteSourceSpan;\n}\n\nexport interface AstVisitor {\n  /**\n   * The `visitUnary` method is declared as optional for backwards compatibility. In an upcoming\n   * major release, this method will be made required.\n   */\n  visitUnary?(ast: Unary, context: any): any;\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  /**\n   * The `visitThisReceiver` method is declared as optional for backwards compatibility.\n   * In an upcoming major release, this method will be made required.\n   */\n  visitThisReceiver?(ast: ThisReceiver, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any;\n  visitCall(ast: Call, context: any): any;\n  visitSafeCall(ast: SafeCall, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  /**\n   * This function is optionally defined to allow classes that implement this\n   * interface to selectively decide if the specified `ast` should be visited.\n   * @param ast node to visit\n   * @param context context that gets passed to the node and all its children\n   */\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visit(ast: AST, context?: any): any {\n    // The default implementation just visits every node.\n    // Classes that extend RecursiveAstVisitor should override this function\n    // to selectively visit the specified node.\n    ast.visit(this, context);\n  }\n  visitUnary(ast: Unary, context: any): any {\n    this.visit(ast.expr, context);\n  }\n  visitBinary(ast: Binary, context: any): any {\n    this.visit(ast.left, context);\n    this.visit(ast.right, context);\n  }\n  visitChain(ast: Chain, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitConditional(ast: Conditional, context: any): any {\n    this.visit(ast.condition, context);\n    this.visit(ast.trueExp, context);\n    this.visit(ast.falseExp, context);\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.visit(ast.exp, context);\n    this.visitAll(ast.args, context);\n  }\n  visitImplicitReceiver(ast: ThisReceiver, context: any): any {}\n  visitThisReceiver(ast: ThisReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n    this.visit(ast.value, context);\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any {\n    this.visitAll(ast.values, context);\n  }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    this.visit(ast.expression, context);\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.value, context);\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    this.visit(ast.receiver, context);\n  }\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visit(ast.key, context);\n  }\n  visitCall(ast: Call, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  visitSafeCall(ast: SafeCall, context: any): any {\n    this.visit(ast.receiver, context);\n    this.visitAll(ast.args, context);\n  }\n  // This is not part of the AstVisitor interface, just a helper method\n  visitAll(asts: AST[], context: any): any {\n    for (const ast of asts) {\n      this.visit(ast, context);\n    }\n  }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name,\n        ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(\n        ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    switch (ast.operator) {\n      case '+':\n        return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      case '-':\n        return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n      default:\n        throw new Error(`Unknown unary operator ${ast.operator}`);\n    }\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(\n        ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(\n        ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this),\n        ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(\n        ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args),\n        ast.nameSpan);\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this),\n        ast.value.visit(this));\n  }\n\n  visitCall(ast: Call, context: any): AST {\n    return new Call(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    return new SafeCall(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), this.visitAll(ast.args),\n        ast.argumentSpan);\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    return new SafeKeyedRead(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n  }\n}\n\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nexport class AstMemoryEfficientTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitThisReceiver(ast: ThisReceiver, context: any): AST {\n    return ast;\n  }\n\n  visitInterpolation(ast: Interpolation, context: any): Interpolation {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions)\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n    return ast;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return ast;\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const value = ast.value.visit(this);\n    if (receiver !== ast.receiver || value !== ast.value) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n    }\n    return ast;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    const values = this.visitAll(ast.values);\n    if (values !== ast.values) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n    }\n    return ast;\n  }\n\n  visitUnary(ast: Unary, context: any): AST {\n    const expr = ast.expr.visit(this);\n    if (expr !== ast.expr) {\n      switch (ast.operator) {\n        case '+':\n          return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n        case '-':\n          return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n        default:\n          throw new Error(`Unknown unary operator ${ast.operator}`);\n      }\n    }\n    return ast;\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    const left = ast.left.visit(this);\n    const right = ast.right.visit(this);\n    if (left !== ast.left || right !== ast.right) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n    }\n    return ast;\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new PrefixNot(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    const condition = ast.condition.visit(this);\n    const trueExp = ast.trueExp.visit(this);\n    const falseExp = ast.falseExp.visit(this);\n    if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n      return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n    }\n    return ast;\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    const exp = ast.exp.visit(this);\n    const args = this.visitAll(ast.args);\n    if (exp !== ast.exp || args !== ast.args) {\n      return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n    }\n    return ast;\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    const value = ast.value.visit(this);\n    if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n    }\n    return ast;\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    let modified = false;\n    for (let i = 0; i < asts.length; ++i) {\n      const original = asts[i];\n      const value = original.visit(this);\n      res[i] = value;\n      modified = modified || value !== original;\n    }\n    return modified ? res : asts;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new Chain(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n\n  visitCall(ast: Call, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new Call(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitSafeCall(ast: SafeCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new SafeCall(ast.span, ast.sourceSpan, receiver, args, ast.argumentSpan);\n    }\n    return ast;\n  }\n\n  visitSafeKeyedRead(ast: SafeKeyedRead, context: any): AST {\n    const obj = ast.receiver.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.receiver || key !== ast.key) {\n      return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n}\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public expression: ASTWithSource, public type: ParsedPropertyType,\n      public sourceSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan,\n      public valueSpan: ParseSourceSpan|undefined) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  ANIMATION\n}\n\nexport const enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Animation events have a phase\n  constructor(\n      public name: string, public targetOrPhase: string, public type: ParsedEventType,\n      public handler: ASTWithSource, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan, readonly keySpan: ParseSourceSpan) {}\n}\n\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\nexport class ParsedVariable {\n  constructor(\n      public readonly name: string, public readonly value: string,\n      public readonly sourceSpan: ParseSourceSpan, public readonly keySpan: ParseSourceSpan,\n      public readonly valueSpan?: ParseSourceSpan) {}\n}\n\nexport const enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: ASTWithSource, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      readonly keySpan: ParseSourceSpan|undefined, public valueSpan: ParseSourceSpan|undefined) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport * as o from '../output/output_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class EventHandlerVars {\n  static event = o.variable('$event');\n}\n\nexport interface LocalResolver {\n  getLocal(name: string): o.Expression|null;\n  notifyImplicitReceiverUse(): void;\n  globals?: Set<string>;\n  maybeRestoreView(): void;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, baseSourceSpan?: ParseSourceSpan, implicitReceiverAccesses?: Set<string>,\n    globals?: Set<string>): o.Statement[] {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver(globals);\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false, baseSourceSpan,\n      implicitReceiverAccesses);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const lastIndex = actionStmts.length - 1;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    // Ensure that the value of the last expression statement is returned\n    if (lastStatement instanceof o.ExpressionStatement) {\n      actionStmts[lastIndex] = new o.ReturnStatement(lastStatement.expr);\n    }\n  }\n  return actionStmts;\n}\n\nexport interface BuiltinConverter {\n  (args: o.Expression[]): o.Expression;\n}\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver|null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, /* supportsInterpolation */ false);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  const stmts: o.Statement[] = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  return new ConvertPropertyBindingResult(stmts, outputExpr);\n}\n\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nexport function convertUpdateArguments(\n    localResolver: LocalResolver, contextVariableExpression: o.Expression,\n    expressionWithArgumentsToExtract: cdAst.Interpolation, bindingId: string) {\n  const visitor = new _AstToIrVisitor(\n      localResolver, contextVariableExpression, bindingId, /* supportsInterpolation */ true);\n  const outputExpr = visitor.visitInterpolation(expressionWithArgumentsToExtract, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const stmts = getStatementsFromVisitor(visitor, bindingId);\n  const args = outputExpr.args;\n  return {stmts, args};\n}\n\nfunction getStatementsFromVisitor(visitor: _AstToIrVisitor, bindingId: string) {\n  const stmts: o.Statement[] = [];\n  for (let i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nfunction temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) {\n    super();\n  }\n  override visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  override visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  override visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n  public usesImplicitReceiver: boolean = false;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private supportsInterpolation: boolean,\n      private baseSourceSpan?: ParseSourceSpan, private implicitReceiverAccesses?: Set<string>) {}\n\n  visitUnary(ast: cdAst.Unary, mode: _Mode): any {\n    let op: o.UnaryOperator;\n    switch (ast.operator) {\n      case '+':\n        op = o.UnaryOperator.Plus;\n        break;\n      case '-':\n        op = o.UnaryOperator.Minus;\n        break;\n      default:\n        throw new Error(`Unsupported operator ${ast.operator}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.UnaryOperatorExpr(\n            op, this._visit(ast.expr, _Mode.Expression), undefined,\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      case '??':\n        return this.convertNullishCoalesce(ast, mode);\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression),\n            undefined, this.convertSourceSpan(ast.span)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode,\n        value.conditional(\n            this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression),\n            this.convertSourceSpan(ast.span)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    this.usesImplicitReceiver = true;\n    return this._implicitReceiver;\n  }\n\n  visitThisReceiver(ast: cdAst.ThisReceiver, mode: _Mode): any {\n    return this.visitImplicitReceiver(ast, mode);\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): InterpolationExpression {\n    if (!this.supportsInterpolation) {\n      throw new Error('Unexpected interpolation');\n    }\n\n    ensureExpressionMode(mode, ast);\n    let args: o.Expression[] = [];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    const strings = ast.strings;\n    if (strings.length === 2 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (ast.expressions.length >= 9) {\n      // 9 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [o.literalArr(args)];\n    }\n\n    return new InterpolationExpression(args);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode,\n          this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n\n    if (obj === this._implicitReceiver) {\n      this._localResolver.maybeRestoreView();\n    }\n\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(\n        mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n  }\n\n  private _getLocal(name: string, receiver: cdAst.AST): o.Expression|null {\n    if (this._localResolver.globals?.has(name) && receiver instanceof cdAst.ThisReceiver) {\n      return null;\n    }\n\n    return this._localResolver.getLocal(name);\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, this._visit(ast.expression, _Mode.Expression));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name, ast.receiver);\n        if (result) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        }\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name, ast.receiver);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          this.addImplicitReceiverAccess(ast.name);\n        } else {\n          // Otherwise it's an error.\n          const receiver = ast.name;\n          const value = (ast.value instanceof cdAst.PropertyRead) ? ast.value.name : undefined;\n          throw new Error(`Cannot assign value \"${value}\" to template variable \"${\n              receiver}\". Template variables are read-only.`);\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name, this.convertSourceSpan(ast.span));\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeKeyedRead(ast: cdAst.SafeKeyedRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any {\n    return asts.map(ast => this._visit(ast, mode));\n  }\n\n  visitCall(ast: cdAst.Call, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    }\n\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n\n    if (ast instanceof BuiltinFunctionCall) {\n      return convertToStatementIfNeeded(mode, ast.converter(convertedArgs));\n    }\n\n    const receiver = ast.receiver;\n    if (receiver instanceof cdAst.PropertyRead &&\n        receiver.receiver instanceof cdAst.ImplicitReceiver &&\n        !(receiver.receiver instanceof cdAst.ThisReceiver) && receiver.name === '$any') {\n      if (convertedArgs.length !== 1) {\n        throw new Error(`Invalid call to $any, expected 1 argument but received ${\n            convertedArgs.length || 'none'}`);\n      }\n      return convertToStatementIfNeeded(mode, convertedArgs[0] as o.Expression);\n    }\n\n    const call = this._visit(receiver, _Mode.Expression)\n                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n    return convertToStatementIfNeeded(mode, call);\n  }\n\n  visitSafeCall(ast: cdAst.SafeCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafePropertyRead|cdAst.SafeKeyedRead|cdAst.SafeCall,\n      mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  .   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr|undefined = undefined;\n    if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.Call(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.args,\n              leftMostSafe.argumentSpan));\n    } else if (leftMostSafe instanceof cdAst.SafeKeyedRead) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.KeyedRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(\n              leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan,\n              leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.NULL_EXPR, access));\n  }\n\n  private convertNullishCoalesce(ast: cdAst.Binary, mode: _Mode): any {\n    const left: o.Expression = this._visit(ast.left, _Mode.Expression);\n    const right: o.Expression = this._visit(ast.right, _Mode.Expression);\n    const temporary = this.allocateTemporary();\n    this.releaseTemporary(temporary);\n\n    // Generate the following expression. It is identical to how TS\n    // transpiles binary expressions with a nullish coalescing operator.\n    // let temp;\n    // (temp = a) !== null && temp !== undefined ? temp : b;\n    return convertToStatementIfNeeded(\n        mode,\n        temporary.set(left)\n            .notIdentical(o.NULL_EXPR)\n            .and(temporary.notIdentical(o.literal(undefined)))\n            .conditional(temporary, right));\n  }\n\n  // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs to be transformed initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeKeyedRead {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary) {\n        return null;\n      },\n      visitBinary(ast: cdAst.Binary) {\n        return null;\n      },\n      visitChain(ast: cdAst.Chain) {\n        return null;\n      },\n      visitConditional(ast: cdAst.Conditional) {\n        return null;\n      },\n      visitCall(ast: cdAst.Call) {\n        return visit(this, ast.receiver);\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return null;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return null;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return null;\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return visit(this, ast.receiver);\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return null;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return null;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return null;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return null;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return null;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return null;\n      },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) {\n        return visit(this, ast.expression);\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return visit(this, ast.receiver);\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return null;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporaryInSafeAccess(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitUnary(ast: cdAst.Unary): boolean {\n        return visit(this, ast.expr);\n      },\n      visitBinary(ast: cdAst.Binary): boolean {\n        return visit(this, ast.left) || visit(this, ast.right);\n      },\n      visitChain(ast: cdAst.Chain) {\n        return false;\n      },\n      visitConditional(ast: cdAst.Conditional): boolean {\n        return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n      },\n      visitCall(ast: cdAst.Call) {\n        return true;\n      },\n      visitSafeCall(ast: cdAst.SafeCall) {\n        return true;\n      },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) {\n        return false;\n      },\n      visitThisReceiver(ast: cdAst.ThisReceiver) {\n        return false;\n      },\n      visitInterpolation(ast: cdAst.Interpolation) {\n        return visitSome(this, ast.expressions);\n      },\n      visitKeyedRead(ast: cdAst.KeyedRead) {\n        return false;\n      },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) {\n        return false;\n      },\n      visitLiteralArray(ast: cdAst.LiteralArray) {\n        return true;\n      },\n      visitLiteralMap(ast: cdAst.LiteralMap) {\n        return true;\n      },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) {\n        return false;\n      },\n      visitPipe(ast: cdAst.BindingPipe) {\n        return true;\n      },\n      visitPrefixNot(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitNonNullAssert(ast: cdAst.PrefixNot) {\n        return visit(this, ast.expression);\n      },\n      visitPropertyRead(ast: cdAst.PropertyRead) {\n        return false;\n      },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) {\n        return false;\n      },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return false;\n      },\n      visitSafeKeyedRead(ast: cdAst.SafeKeyedRead) {\n        return false;\n      }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n\n  /**\n   * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n   *\n   * `ParseSpan` objects are relative to the start of the expression.\n   * This method converts these to full `ParseSourceSpan` objects that\n   * show where the span is within the overall source file.\n   *\n   * @param span the relative span to convert.\n   * @returns a `ParseSourceSpan` for the given span or null if no\n   * `baseSourceSpan` was provided to this class.\n   */\n  private convertSourceSpan(span: cdAst.ParseSpan) {\n    if (this.baseSourceSpan) {\n      const start = this.baseSourceSpan.start.moveBy(span.start);\n      const end = this.baseSourceSpan.start.moveBy(span.end);\n      const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n      return new ParseSourceSpan(start, end, fullStart);\n    } else {\n      return null;\n    }\n  }\n\n  /** Adds the name of an AST to the list of implicit receiver accesses. */\n  private addImplicitReceiverAccess(name: string) {\n    if (this.implicitReceiverAccesses) {\n      this.implicitReceiverAccesses.add(name);\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nfunction unsupported(): never {\n  throw new Error('Unsupported operation');\n}\n\nclass InterpolationExpression extends o.Expression {\n  constructor(public args: o.Expression[]) {\n    super(null, null);\n  }\n\n  override isConstant = unsupported;\n  override isEquivalent = unsupported;\n  override visitExpression = unsupported;\n  override clone = unsupported;\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  constructor(public globals?: Set<string>) {}\n  notifyImplicitReceiverUse(): void {}\n  maybeRestoreView(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nexport class BuiltinFunctionCall extends cdAst.Call {\n  constructor(\n      span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, args: cdAst.AST[],\n      public converter: BuiltinConverter) {\n    super(span, sourceSpan, new cdAst.EmptyExpr(span, sourceSpan), args, null!);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\n\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\nlet _SECURITY_SCHEMA!: {[k: string]: SecurityContext};\n\nexport function SECURITY_SCHEMA(): {[k: string]: SecurityContext} {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {};\n    // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n\n    registerContext(SecurityContext.HTML, [\n      'iframe|srcdoc',\n      '*|innerHTML',\n      '*|outerHTML',\n    ]);\n    registerContext(SecurityContext.STYLE, ['*|style']);\n    // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n    registerContext(SecurityContext.URL, [\n      '*|formAction',\n      'area|href',\n      'area|ping',\n      'audio|src',\n      'a|href',\n      'a|ping',\n      'blockquote|cite',\n      'body|background',\n      'del|cite',\n      'form|action',\n      'img|src',\n      'input|src',\n      'ins|cite',\n      'q|cite',\n      'source|src',\n      'track|src',\n      'video|poster',\n      'video|src',\n    ]);\n    registerContext(SecurityContext.RESOURCE_URL, [\n      'applet|code',\n      'applet|codebase',\n      'base|href',\n      'embed|src',\n      'frame|src',\n      'head|profile',\n      'html|manifest',\n      'iframe|src',\n      'link|href',\n      'media|src',\n      'object|codebase',\n      'object|data',\n      'script|src',\n    ]);\n  }\n  return _SECURITY_SCHEMA;\n}\n\nfunction registerContext(ctx: SecurityContext, specs: string[]) {\n  for (const spec of specs) _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n}\n\n/**\n * The set of security-sensitive attributes of an `<iframe>` that *must* be\n * applied as a static attribute only. This ensures that all security-sensitive\n * attributes are taken into account while creating an instance of an `<iframe>`\n * at runtime.\n *\n * Note: avoid using this set directly, use the `isIframeSecuritySensitiveAttr` function\n * in the code instead.\n */\nexport const IFRAME_SECURITY_SENSITIVE_ATTRS =\n    new Set(['sandbox', 'allow', 'allowfullscreen', 'referrerpolicy', 'csp', 'fetchpriority']);\n\n/**\n * Checks whether a given attribute name might represent a security-sensitive\n * attribute of an <iframe>.\n */\nexport function isIframeSecuritySensitiveAttr(attrName: string): boolean {\n  // The `setAttribute` DOM API is case-insensitive, so we lowercase the value\n  // before checking it against a known security-sensitive attributes.\n  return IFRAME_SECURITY_SENSITIVE_ATTRS.has(attrName.toLowerCase());\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The following set contains all keywords that can be used in the animation css shorthand\n * property and is used during the scoping of keyframes to make sure such keywords\n * are not modified.\n */\nconst animationKeywords = new Set([\n  // global values\n  'inherit', 'initial', 'revert', 'unset',\n  // animation-direction\n  'alternate', 'alternate-reverse', 'normal', 'reverse',\n  // animation-fill-mode\n  'backwards', 'both', 'forwards', 'none',\n  // animation-play-state\n  'paused', 'running',\n  // animation-timing-function\n  'ease', 'ease-in', 'ease-in-out', 'ease-out', 'linear', 'step-start', 'step-end',\n  // `steps()` function\n  'end', 'jump-both', 'jump-end', 'jump-none', 'jump-start', 'start'\n]);\n\n/**\n * The following class has its origin from a port of shadowCSS from webcomponents.js to TypeScript.\n * It has since diverge in many ways to tailor Angular's needs.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM.\n  The selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\nexport class ShadowCss {\n  /*\n   * Shim some cssText with the given selector. Returns cssText that can be included in the document\n   *\n   * The selector is the attribute added to all elements inside the host,\n   * The hostSelector is the attribute added to the host itself.\n   */\n  shimCssText(cssText: string, selector: string, hostSelector: string = ''): string {\n    // **NOTE**: Do not strip comments as this will cause component sourcemaps to break\n    // due to shift in lines.\n\n    // Collect comments and replace them with a placeholder, this is done to avoid complicating\n    // the rule parsing RegExp and keep it safer.\n    const comments: string[] = [];\n    cssText = cssText.replace(_commentRe, (m) => {\n      if (m.match(_commentWithHashRe)) {\n        comments.push(m);\n      } else {\n        // Replace non hash comments with empty lines.\n        // This is done so that we do not leak any senstive data in comments.\n        const newLinesMatches = m.match(_newLinesRe);\n        comments.push((newLinesMatches?.join('') ?? '') + '\\n');\n      }\n\n      return COMMENT_PLACEHOLDER;\n    });\n\n    cssText = this._insertDirectives(cssText);\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    // Add back comments at the original position.\n    let commentIdx = 0;\n    return scopedCssText.replace(_commentWithHashPlaceHolderRe, () => comments[commentIdx++]);\n  }\n\n  private _insertDirectives(cssText: string): string {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n\n  /**\n   * Process styles to add scope to keyframes.\n   *\n   * Modify both the names of the keyframes defined in the component styles and also the css\n   * animation rules using them.\n   *\n   * Animation rules using keyframes defined elsewhere are not modified to allow for globally\n   * defined keyframes.\n   *\n   * For example, we convert this css:\n   *\n   * ```\n   * .box {\n   *   animation: box-animation 1s forwards;\n   * }\n   *\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * to this:\n   *\n   * ```\n   * .box {\n   *   animation: scopeName_box-animation 1s forwards;\n   * }\n   *\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * @param cssText the component's css text that needs to be scoped.\n   * @param scopeSelector the component's scope selector.\n   *\n   * @returns the scoped css text.\n   */\n  private _scopeKeyframesRelatedCss(cssText: string, scopeSelector: string): string {\n    const unscopedKeyframesSet = new Set<string>();\n    const scopedKeyframesCssText = processRules(\n        cssText,\n        rule => this._scopeLocalKeyframeDeclarations(rule, scopeSelector, unscopedKeyframesSet));\n    return processRules(\n        scopedKeyframesCssText,\n        rule => this._scopeAnimationRule(rule, scopeSelector, unscopedKeyframesSet));\n  }\n\n  /**\n   * Scopes local keyframes names, returning the updated css rule and it also\n   * adds the original keyframe name to a provided set to collect all keyframes names\n   * so that it can later be used to scope the animation rules.\n   *\n   * For example, it takes a rule such as:\n   *\n   * ```\n   * @keyframes box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   *\n   * and returns:\n   *\n   * ```\n   * @keyframes scopeName_box-animation {\n   *   to {\n   *     background-color: green;\n   *   }\n   * }\n   * ```\n   * and as a side effect it adds \"box-animation\" to the `unscopedKeyframesSet` set\n   *\n   * @param cssRule the css rule to process.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names (which can be\n   * modified as a side effect)\n   *\n   * @returns the css rule modified with the scoped keyframes name.\n   */\n  private _scopeLocalKeyframeDeclarations(\n      rule: CssRule, scopeSelector: string, unscopedKeyframesSet: Set<string>): CssRule {\n    return {\n      ...rule,\n      selector: rule.selector.replace(\n          /(^@(?:-webkit-)?keyframes(?:\\s+))(['\"]?)(.+)\\2(\\s*)$/,\n          (_, start, quote, keyframeName, endSpaces) => {\n            unscopedKeyframesSet.add(unescapeQuotes(keyframeName, quote));\n            return `${start}${quote}${scopeSelector}_${keyframeName}${quote}${endSpaces}`;\n          }),\n    };\n  }\n\n  /**\n   * Function used to scope a keyframes name (obtained from an animation declaration)\n   * using an existing set of unscopedKeyframes names to discern if the scoping needs to be\n   * performed (keyframes names of keyframes not defined in the component's css need not to be\n   * scoped).\n   *\n   * @param keyframe the keyframes name to check.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the scoped name of the keyframe, or the original name is the name need not to be\n   * scoped.\n   */\n  private _scopeAnimationKeyframe(\n      keyframe: string, scopeSelector: string, unscopedKeyframesSet: ReadonlySet<string>): string {\n    return keyframe.replace(/^(\\s*)(['\"]?)(.+?)\\2(\\s*)$/, (_, spaces1, quote, name, spaces2) => {\n      name = `${unscopedKeyframesSet.has(unescapeQuotes(name, quote)) ? scopeSelector + '_' : ''}${\n          name}`;\n      return `${spaces1}${quote}${name}${quote}${spaces2}`;\n    });\n  }\n\n  /**\n   * Regular expression used to extrapolate the possible keyframes from an\n   * animation declaration (with possibly multiple animation definitions)\n   *\n   * The regular expression can be divided in three parts\n   *  - (^|\\s+)\n   *    simply captures how many (if any) leading whitespaces are present\n   *  - (?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))\n   *    captures two different possible keyframes, ones which are quoted or ones which are valid css\n   * idents (custom properties excluded)\n   *  - (?=[,\\s;]|$)\n   *    simply matches the end of the possible keyframe, valid endings are: a comma, a space, a\n   * semicolon or the end of the string\n   */\n  private _animationDeclarationKeyframesRe =\n      /(^|\\s+)(?:(?:(['\"])((?:\\\\\\\\|\\\\\\2|(?!\\2).)+)\\2)|(-?[A-Za-z][\\w\\-]*))(?=[,\\s]|$)/g;\n\n  /**\n   * Scope an animation rule so that the keyframes mentioned in such rule\n   * are scoped if defined in the component's css and left untouched otherwise.\n   *\n   * It can scope values of both the 'animation' and 'animation-name' properties.\n   *\n   * @param rule css rule to scope.\n   * @param scopeSelector the component's scope selector.\n   * @param unscopedKeyframesSet the set of unscoped keyframes names.\n   *\n   * @returns the updated css rule.\n   **/\n  private _scopeAnimationRule(\n      rule: CssRule, scopeSelector: string, unscopedKeyframesSet: ReadonlySet<string>): CssRule {\n    let content = rule.content.replace(\n        /((?:^|\\s+|;)(?:-webkit-)?animation(?:\\s*):(?:\\s*))([^;]+)/g,\n        (_, start, animationDeclarations) => start +\n            animationDeclarations.replace(\n                this._animationDeclarationKeyframesRe,\n                (original: string, leadingSpaces: string, quote = '', quotedName: string,\n                 nonQuotedName: string) => {\n                  if (quotedName) {\n                    return `${leadingSpaces}${\n                        this._scopeAnimationKeyframe(\n                            `${quote}${quotedName}${quote}`, scopeSelector, unscopedKeyframesSet)}`;\n                  } else {\n                    return animationKeywords.has(nonQuotedName) ?\n                        original :\n                        `${leadingSpaces}${\n                            this._scopeAnimationKeyframe(\n                                nonQuotedName, scopeSelector, unscopedKeyframesSet)}`;\n                  }\n                }));\n    content = content.replace(\n        /((?:^|\\s+|;)(?:-webkit-)?animation-name(?:\\s*):(?:\\s*))([^;]+)/g,\n        (_match, start, commaSeparatedKeyframes) => `${start}${\n            commaSeparatedKeyframes.split(',')\n                .map(\n                    (keyframe: string) =>\n                        this._scopeAnimationKeyframe(keyframe, scopeSelector, unscopedKeyframesSet))\n                .join(',')}`);\n    return {...rule, content};\n  }\n\n  /*\n   * Process styles to convert native ShadowDOM rules that will trip\n   * up the css parser; we rely on decorating the stylesheet with inert rules.\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-next-selector { content: ':host menu-item'; }\n   * ::content menu-item {\n   *\n   * to this:\n   *\n   * scopeName menu-item {\n   *\n   **/\n  private _insertPolyfillDirectivesInCssText(cssText: string): string {\n    return cssText.replace(_cssContentNextSelectorRe, function(...m: string[]) {\n      return m[2] + '{';\n    });\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-rule {\n   *   content: ':host menu-item';\n   * ...\n   * }\n   *\n   * to this:\n   *\n   * scopeName menu-item {...}\n   *\n   **/\n  private _insertPolyfillRulesInCssText(cssText: string): string {\n    return cssText.replace(_cssContentRuleRe, (...m: string[]) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n\n  /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n   *\n   *  .foo {... }\n   *\n   *  and converts this to\n   *\n   *  scopeName .foo { ... }\n   */\n  private _scopeCssText(cssText: string, scopeSelector: string, hostSelector: string): string {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeKeyframesRelatedCss(cssText, scopeSelector);\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n   * occasions, e.g. -webkit-calc on Safari.)\n   * For example, we convert this rule:\n   *\n   * @polyfill-unscoped-rule {\n   *   content: 'menu-item';\n   * ... }\n   *\n   * to this:\n   *\n   * menu-item {...}\n   *\n   **/\n  private _extractUnscopedRulesFromCssText(cssText: string): string {\n    let r = '';\n    let m: RegExpExecArray|null;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n\n  /*\n   * convert a rule like :host(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar\n   */\n  private _convertColonHost(cssText: string): string {\n    return cssText.replace(_cssColonHostRe, (_, hostSelectors: string, otherSelectors: string) => {\n      if (hostSelectors) {\n        const convertedSelectors: string[] = [];\n        const hostSelectorArray = hostSelectors.split(',').map((p) => p.trim());\n        for (const hostSelector of hostSelectorArray) {\n          if (!hostSelector) break;\n          const convertedSelector =\n              _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n          convertedSelectors.push(convertedSelector);\n        }\n        return convertedSelectors.join(',');\n      } else {\n        return _polyfillHostNoCombinator + otherSelectors;\n      }\n    });\n  }\n\n  /*\n   * convert a rule like :host-context(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\n   *\n   * and\n   *\n   * :host-context(.foo:host) .bar { ... }\n   *\n   * to\n   *\n   * .foo<scopeName> .bar { ... }\n   */\n  private _convertColonHostContext(cssText: string): string {\n    return cssText.replace(_cssColonHostContextReGlobal, (selectorText) => {\n      // We have captured a selector that contains a `:host-context` rule.\n\n      // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n      // Each context selector group will contain a list of host-context selectors that must match\n      // an ancestor of the host.\n      // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n      const contextSelectorGroups: string[][] = [[]];\n\n      // There may be more than `:host-context` in this selector so `selectorText` could look like:\n      // `:host-context(.one):host-context(.two)`.\n      // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n      // `:host-context` selectors from this selector.\n      let match: RegExpExecArray|null;\n      while ((match = _cssColonHostContextRe.exec(selectorText))) {\n        // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n\n        // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n        const newContextSelectors =\n            (match[1] ?? '').trim().split(',').map((m) => m.trim()).filter((m) => m !== '');\n\n        // We must duplicate the current selector group for each of these new selectors.\n        // For example if the current groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c'],\n        //   ['x', 'y', 'z'],\n        // ]\n        // ```\n        // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n        // groups are:\n        // ```\n        // [\n        //   ['a', 'b', 'c', 'm'],\n        //   ['x', 'y', 'z', 'm'],\n        //   ['a', 'b', 'c', 'n'],\n        //   ['x', 'y', 'z', 'n'],\n        // ]\n        // ```\n        const contextSelectorGroupsLength = contextSelectorGroups.length;\n        repeatGroups(contextSelectorGroups, newContextSelectors.length);\n        for (let i = 0; i < newContextSelectors.length; i++) {\n          for (let j = 0; j < contextSelectorGroupsLength; j++) {\n            contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);\n          }\n        }\n\n        // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n        selectorText = match[2];\n      }\n\n      // The context selectors now must be combined with each other to capture all the possible\n      // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n      // info about how this is done.\n      return contextSelectorGroups\n          .map((contextSelectors) => combineHostContextSelectors(contextSelectors, selectorText))\n          .join(', ');\n    });\n  }\n\n  /*\n   * Convert combinators like ::shadow and pseudo-elements like ::content\n   * by replacing with space.\n   */\n  private _convertShadowDOMSelectors(cssText: string): string {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n\n  // change a selector like 'div' to 'name div'\n  private _scopeSelectors(cssText: string, scopeSelector: string, hostSelector: string): string {\n    return processRules(cssText, (rule: CssRule) => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] !== '@') {\n        selector = this._scopeSelector(rule.selector, scopeSelector, hostSelector);\n      } else if (\n          rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n          rule.selector.startsWith('@document') || rule.selector.startsWith('@layer') ||\n          rule.selector.startsWith('@container') || rule.selector.startsWith('@scope')) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n        content = this._stripScopingSelectors(rule.content);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n\n  /**\n   * Handle a css text that is within a rule that should not contain scope selectors by simply\n   * removing them! An example of such a rule is `@font-face`.\n   *\n   * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\n   * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\n   * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\n   * can end up with broken css if the imported styles happen to contain @font-face rules.\n   *\n   * For example:\n   *\n   * ```\n   * :host ::ng-deep {\n   *   import 'some/lib/containing/font-face';\n   * }\n   *\n   * Similar logic applies to `@page` rules which can contain a particular set of properties,\n   * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\n   * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\n   * ```\n   */\n  private _stripScopingSelectors(cssText: string): string {\n    return processRules(cssText, (rule) => {\n      const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\n                           .replace(_polyfillHostNoCombinatorRe, ' ');\n      return new CssRule(selector, rule.content);\n    });\n  }\n\n  private _scopeSelector(selector: string, scopeSelector: string, hostSelector: string): string {\n    return selector.split(',')\n        .map((part) => part.trim().split(_shadowDeepSelectors))\n        .map((deepParts) => {\n          const [shallowPart, ...otherParts] = deepParts;\n          const applyScope = (shallowPart: string) => {\n            if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n              return this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n            } else {\n              return shallowPart;\n            }\n          };\n          return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n        .join(', ');\n  }\n\n  private _selectorNeedsScoping(selector: string, scopeSelector: string): boolean {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n\n  private _makeScopeMatcher(scopeSelector: string): RegExp {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n\n  // scope via name and [is=name]\n  private _applySimpleSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = `[${hostSelector}]`;\n      return selector\n          .replace(\n              _polyfillHostNoCombinatorRe,\n              (hnc, selector) => {\n                return selector.replace(\n                    /([^:]*)(:*)(.*)/,\n                    (_: string, before: string, colon: string, after: string) => {\n                      return before + replaceBy + colon + after;\n                    });\n              })\n          .replace(_polyfillHostRe, replaceBy + ' ');\n    }\n\n    return scopeSelector + ' ' + selector;\n  }\n\n  // return a selector with [name] suffix on each simple selector\n  // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n  private _applySelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_: string, ...parts: string[]) => parts[0]);\n\n    const attrName = '[' + scopeSelector + ']';\n\n    const _scopeSelectorPart = (p: string) => {\n      let scopedP = p.trim();\n\n      if (!scopedP) {\n        return '';\n      }\n\n      if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n      } else {\n        // remove :host since it should be unnecessary\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)(.*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n\n      return scopedP;\n    };\n\n    const safeContent = new SafeSelector(selector);\n    selector = safeContent.content();\n\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res: RegExpExecArray|null;\n    const sep = /( |>|\\+|~(?!=))\\s*/g;\n\n    // If a selector appears before :host it should not be shimmed as it\n    // matches on ancestor elements and not on elements in the host's shadow\n    // `:host-context(div)` is transformed to\n    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n    // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n    // Historically `component-tag:host` was matching the component so we also want to preserve\n    // this behavior to avoid breaking legacy apps (it should not match).\n    // The behavior should be:\n    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n    //   `:host-context(tag)`)\n    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n    let shouldScope = !hasHost;\n\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index).trim();\n\n      // A space following an escaped hex value and followed by another hex character\n      // (ie: \".\\fc ber\" for \".Ã¼ber\") is not a separator between 2 selectors\n      // also keep in mind that backslashes are replaced by a placeholder by SafeSelector\n      // These escaped selectors happen for example when esbuild runs with optimization.minify.\n      if (part.match(_placeholderRe) && selector[res.index + 1]?.match(/[a-fA-F\\d]/)) {\n        continue;\n      }\n\n      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n      const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n\n    const part = selector.substring(startIndex);\n    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n\n    // replace the placeholders with their original values\n    return safeContent.restore(scopedSelector);\n  }\n\n  private _insertPolyfillHostInCssText(selector: string): string {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext)\n        .replace(_colonHostRe, _polyfillHost);\n  }\n}\n\nclass SafeSelector {\n  private placeholders: string[] = [];\n  private index = 0;\n  private _content: string;\n\n  constructor(selector: string) {\n    // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\n\n    // CSS allows for certain special characters to be used in selectors if they're escaped.\n    // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n    // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n    // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n    // that our handling of pseudo-selectors doesn't mess with them.\n    selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\n\n    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(exp);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  restore(content: string): string {\n    return content.replace(_placeholderRe, (_ph, index) => this.placeholders[+index]);\n  }\n\n  content(): string {\n    return this._content;\n  }\n\n  /**\n   * Replaces all of the substrings that match a regex within a\n   * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\n   */\n  private _escapeRegexMatches(content: string, pattern: RegExp): string {\n    return content.replace(pattern, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n  }\n}\n\nconst _cssContentNextSelectorRe =\n    /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe =\n    /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = '(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n  /::shadow/g,\n  /::content/g,\n  // Deprecated selectors\n  /\\/shadow-deep\\//g,\n  /\\/shadow\\//g,\n];\n\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\n\nconst _newLinesRe = /\\r?\\n/g;\nconst _commentRe = /\\/\\*[\\s\\S]*?\\*\\//g;\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=/g;\nconst COMMENT_PLACEHOLDER = '%COMMENT%';\nconst _commentWithHashPlaceHolderRe = new RegExp(COMMENT_PLACEHOLDER, 'g');\n\nconst _placeholderRe = /__ph-(\\d+)__/g;\n\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\nconst _ruleRe = new RegExp(\n    `(\\\\s*(?:${COMMENT_PLACEHOLDER}\\\\s*)*)([^;\\\\{\\\\}]+?)(\\\\s*)((?:{%BLOCK%}?\\\\s*;?)|(?:\\\\s*;))`,\n    'g');\nconst CONTENT_PAIRS = new Map([['{', '}']]);\n\nconst COMMA_IN_PLACEHOLDER = '%COMMA_IN_PLACEHOLDER%';\nconst SEMI_IN_PLACEHOLDER = '%SEMI_IN_PLACEHOLDER%';\nconst COLON_IN_PLACEHOLDER = '%COLON_IN_PLACEHOLDER%';\n\nconst _cssCommaInPlaceholderReGlobal = new RegExp(COMMA_IN_PLACEHOLDER, 'g');\nconst _cssSemiInPlaceholderReGlobal = new RegExp(SEMI_IN_PLACEHOLDER, 'g');\nconst _cssColonInPlaceholderReGlobal = new RegExp(COLON_IN_PLACEHOLDER, 'g');\n\nexport class CssRule {\n  constructor(public selector: string, public content: string) {}\n}\n\nexport function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {\n  const escaped = escapeInStrings(input);\n  const inputWithEscapedBlocks = escapeBlocks(escaped, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  let nextBlockIndex = 0;\n  const escapedResult = inputWithEscapedBlocks.escapedString.replace(_ruleRe, (...m: string[]) => {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n  return unescapeInStrings(escapedResult);\n}\n\nclass StringWithEscapedBlocks {\n  constructor(public escapedString: string, public blocks: string[]) {}\n}\n\nfunction escapeBlocks(\n    input: string, charPairs: Map<string, string>, placeholder: string): StringWithEscapedBlocks {\n  const resultParts: string[] = [];\n  const escapedBlocks: string[] = [];\n  let openCharCount = 0;\n  let nonBlockStartIndex = 0;\n  let blockStartIndex = -1;\n  let openChar: string|undefined;\n  let closeChar: string|undefined;\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n\n/**\n * Object containing as keys characters that should be substituted by placeholders\n * when found in strings during the css text parsing, and as values the respective\n * placeholders\n */\nconst ESCAPE_IN_STRING_MAP: {[key: string]: string} = {\n  ';': SEMI_IN_PLACEHOLDER,\n  ',': COMMA_IN_PLACEHOLDER,\n  ':': COLON_IN_PLACEHOLDER\n};\n\n/**\n * Parse the provided css text and inside strings (meaning, inside pairs of unescaped single or\n * double quotes) replace specific characters with their respective placeholders as indicated\n * by the `ESCAPE_IN_STRING_MAP` map.\n *\n * For example convert the text\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n * to\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n *\n * This is necessary in order to remove the meaning of some characters when found inside strings\n * (for example `;` indicates the end of a css declaration, `,` the sequence of values and `:` the\n * division between property and value during a declaration, none of these meanings apply when such\n * characters are within strings and so in order to prevent parsing issues they need to be replaced\n * with placeholder text for the duration of the css manipulation process).\n *\n * @param input the original css text.\n *\n * @returns the css text with specific characters in strings replaced by placeholders.\n **/\nfunction escapeInStrings(input: string): string {\n  let result = input;\n  let currentQuoteChar: string|null = null;\n  for (let i = 0; i < result.length; i++) {\n    const char = result[i];\n    if (char === '\\\\') {\n      i++;\n    } else {\n      if (currentQuoteChar !== null) {\n        // index i is inside a quoted sub-string\n        if (char === currentQuoteChar) {\n          currentQuoteChar = null;\n        } else {\n          const placeholder: string|undefined = ESCAPE_IN_STRING_MAP[char];\n          if (placeholder) {\n            result = `${result.substr(0, i)}${placeholder}${result.substr(i + 1)}`;\n            i += placeholder.length - 1;\n          }\n        }\n      } else if (char === '\\'' || char === '\"') {\n        currentQuoteChar = char;\n      }\n    }\n  }\n  return result;\n}\n\n/**\n * Replace in a string all occurrences of keys in the `ESCAPE_IN_STRING_MAP` map with their\n * original representation, this is simply used to revert the changes applied by the\n * escapeInStrings function.\n *\n * For example it reverts the text:\n *  `animation: \"my-anim%COLON_IN_PLACEHOLDER%at\\\"ion\" 1s;`\n * to it's original form of:\n *  `animation: \"my-anim:at\\\"ion\" 1s;`\n *\n * Note: For the sake of simplicity this function does not check that the placeholders are\n * actually inside strings as it would anyway be extremely unlikely to find them outside of strings.\n *\n * @param input the css text containing the placeholders.\n *\n * @returns the css text without the placeholders.\n */\nfunction unescapeInStrings(input: string): string {\n  let result = input.replace(_cssCommaInPlaceholderReGlobal, ',');\n  result = result.replace(_cssSemiInPlaceholderReGlobal, ';');\n  result = result.replace(_cssColonInPlaceholderReGlobal, ':');\n  return result;\n}\n\n/**\n * Unescape all quotes present in a string, but only if the string was actually already\n * quoted.\n *\n * This generates a \"canonical\" representation of strings which can be used to match strings\n * which would otherwise only differ because of differently escaped quotes.\n *\n * For example it converts the string (assumed to be quoted):\n *  `this \\\\\"is\\\\\" a \\\\'\\\\\\\\'test`\n * to:\n *  `this \"is\" a '\\\\\\\\'test`\n * (note that the latter backslashes are not removed as they are not actually escaping the single\n * quote)\n *\n *\n * @param input the string possibly containing escaped quotes.\n * @param isQuoted boolean indicating whether the string was quoted inside a bigger string (if not\n * then it means that it doesn't represent an inner string and thus no unescaping is required)\n *\n * @returns the string in the \"canonical\" representation without escaped quotes.\n */\nfunction unescapeQuotes(str: string, isQuoted: boolean): string {\n  return !isQuoted ? str : str.replace(/((?:^|[^\\\\])(?:\\\\\\\\)*)\\\\(?=['\"])/g, '$1');\n}\n\n/**\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\n * to create a selector that matches the same as `:host-context()`.\n *\n * Given a single context selector `A` we need to output selectors that match on the host and as an\n * ancestor of the host:\n *\n * ```\n * A <hostMarker>, A<hostMarker> {}\n * ```\n *\n * When there is more than one context selector we also have to create combinations of those\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\n *\n * ```\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\n * ```\n *\n * And so on...\n *\n * @param contextSelectors an array of context selectors that will be combined.\n * @param otherSelectors the rest of the selectors that are not context selectors.\n */\nfunction combineHostContextSelectors(contextSelectors: string[], otherSelectors: string): string {\n  const hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0;  // reset the regex to ensure we get an accurate test\n  const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\n\n  // If there are no context selectors then just output a host marker\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n\n  const combined: string[] = [contextSelectors.pop() || ''];\n  while (contextSelectors.length > 0) {\n    const length = combined.length;\n    const contextSelector = contextSelectors.pop();\n    for (let i = 0; i < length; i++) {\n      const previousSelectors = combined[i];\n      // Add the new selector as a descendant of the previous selectors\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\n      // Add the new selector as an ancestor of the previous selectors\n      combined[length + i] = contextSelector + ' ' + previousSelectors;\n      // Add the new selector to act on the same element as the previous selectors\n      combined[i] = contextSelector + previousSelectors;\n    }\n  }\n  // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n  return combined\n      .map(\n          s => otherSelectorsHasHost ?\n              `${s}${otherSelectors}` :\n              `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\n      .join(',');\n}\n\n/**\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\n * stored.\n *\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\n * newly added groups will be clones of the original.\n *\n * @param groups An array of groups of strings that will be repeated. This array is mutated\n *     in-place.\n * @param multiples The number of times the current groups should appear.\n */\nexport function repeatGroups(groups: string[][], multiples: number): void {\n  const length = groups.length;\n  for (let i = 1; i < multiples; i++) {\n    for (let j = 0; j < length; j++) {\n      groups[j + (i * length)] = groups[j].slice(0);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  implicitNamespacePrefix: string|null;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n  preventNamespaceInheritance: boolean;\n\n  isClosedByChild(name: string): boolean;\n  getContentType(prefix?: string): TagContentType;\n}\n\nexport function splitNsName(elementName: string): [string|null, string] {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex === -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string|null): string|null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as core from '../../../../core';\nimport {splitNsName} from '../../../../ml_parser/tags';\nimport * as o from '../../../../output/output_ast';\n\n/**\n * Enumeration of the types of attributes which can be applied to an element.\n */\nexport enum BindingKind {\n  /**\n   * Static attributes.\n   */\n  Attribute,\n\n  /**\n   * Class bindings.\n   */\n  ClassName,\n\n  /**\n   * Style bindings.\n   */\n  StyleProperty,\n\n  /**\n   * Dynamic property bindings.\n   */\n  Property,\n\n  /**\n   * Property or attribute bindings on a template.\n   */\n  Template,\n\n  /**\n   * Internationalized attributes.\n   */\n  I18n,\n\n  /**\n   * TODO: Consider how Animations are handled, and if they should be a distinct BindingKind.\n   */\n  Animation,\n}\n\nconst FLYWEIGHT_ARRAY: ReadonlyArray<o.Expression> = Object.freeze<o.Expression[]>([]);\n\n/**\n * Container for all of the various kinds of attributes which are applied on an element.\n */\nexport class ElementAttributes {\n  private known = new Set<string>();\n  private byKind = new Map<BindingKind, o.Expression[]>;\n\n  projectAs: string|null = null;\n\n  get attributes(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(BindingKind.Attribute) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get classes(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(BindingKind.ClassName) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get styles(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(BindingKind.StyleProperty) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get bindings(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(BindingKind.Property) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get template(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(BindingKind.Template) ?? FLYWEIGHT_ARRAY;\n  }\n\n  get i18n(): ReadonlyArray<o.Expression> {\n    return this.byKind.get(BindingKind.I18n) ?? FLYWEIGHT_ARRAY;\n  }\n\n  add(kind: BindingKind, name: string, value: o.Expression|null): void {\n    if (this.known.has(name)) {\n      return;\n    }\n    this.known.add(name);\n    const array = this.arrayFor(kind);\n    array.push(...getAttributeNameLiterals(name));\n    if (kind === BindingKind.Attribute || kind === BindingKind.StyleProperty) {\n      if (value === null) {\n        throw Error('Attribute & style element attributes must have a value');\n      }\n      array.push(value);\n    }\n  }\n\n  private arrayFor(kind: BindingKind): o.Expression[] {\n    if (!this.byKind.has(kind)) {\n      this.byKind.set(kind, []);\n    }\n    return this.byKind.get(kind)!;\n  }\n}\n\nfunction getAttributeNameLiterals(name: string): o.LiteralExpr[] {\n  const [attributeNamespace, attributeName] = splitNsName(name);\n  const nameLiteral = o.literal(attributeName);\n\n  if (attributeNamespace) {\n    return [\n      o.literal(core.AttributeMarker.NamespaceURI), o.literal(attributeNamespace), nameLiteral\n    ];\n  }\n\n  return [nameLiteral];\n}\n\nexport function assertIsElementAttributes(attrs: any): asserts attrs is ElementAttributes {\n  if (!(attrs instanceof ElementAttributes)) {\n    throw new Error(\n        `AssertionError: ElementAttributes has already been coalesced into the view constants`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Distinguishes different kinds of IR operations.\n *\n * Includes both creation and update operations.\n */\nexport enum OpKind {\n  /**\n   * A special operation type which is used to represent the beginning and end nodes of a linked\n   * list of operations.\n   */\n  ListEnd,\n\n  /**\n   * An operation which wraps an output AST statement.\n   */\n  Statement,\n\n  /**\n   * An operation which declares and initializes a `SemanticVariable`.\n   */\n  Variable,\n\n  /**\n   * An operation to begin rendering of an element.\n   */\n  ElementStart,\n\n  /**\n   * An operation to render an element with no children.\n   */\n  Element,\n\n  /**\n   * An operation which declares an embedded view.\n   */\n  Template,\n\n  /**\n   * An operation to end rendering of an element previously started with `ElementStart`.\n   */\n  ElementEnd,\n\n  /**\n   * An operation to begin an `ng-container`.\n   */\n  ContainerStart,\n\n  /**\n   * An operation for an `ng-container` with no children.\n   */\n  Container,\n\n  /**\n   * An operation to end an `ng-container`.\n   */\n  ContainerEnd,\n\n  /**\n   * An operation disable binding for subsequent elements, which are descendants of a non-bindable\n   * node.\n   */\n  DisableBindings,\n\n  /**\n   * An operation to re-enable binding, after it was previously disabled.\n   */\n  EnableBindings,\n\n  /**\n   * An operation to render a text node.\n   */\n  Text,\n\n  /**\n   * An operation declaring an event listener for an element.\n   */\n  Listener,\n\n  /**\n   * An operation to interpolate text into a text node.\n   */\n  InterpolateText,\n\n  /**\n   * An intermediate binding op, that has not yet been processed into an individual property,\n   * attribute, style, etc.\n   */\n  Binding,\n\n  /**\n   * An operation to bind an expression to a property of an element.\n   */\n  Property,\n\n  /**\n   * An operation to bind an expression to a style property of an element.\n   */\n  StyleProp,\n\n  /**\n   * An operation to bind an expression to a class property of an element.\n   */\n  ClassProp,\n\n  /**\n   * An operation to bind an expression to the styles of an element.\n   */\n  StyleMap,\n\n  /**\n   * An operation to bind an expression to the classes of an element.\n   */\n  ClassMap,\n\n  /**\n   * An operation to advance the runtime's implicit slot context during the update phase of a view.\n   */\n  Advance,\n\n  /**\n   * An operation to instantiate a pipe.\n   */\n  Pipe,\n\n  /**\n   * An operation to associate an attribute with an element.\n   */\n  Attribute,\n\n  /**\n   * A host binding property.\n   */\n  HostProperty,\n\n  /**\n   * A namespace change, which causes the subsequent elements to be processed as either HTML or SVG.\n   */\n  Namespace,\n\n  // TODO: Add Host Listeners, and possibly other host ops also.\n}\n\n/**\n * Distinguishes different kinds of IR expressions.\n */\nexport enum ExpressionKind {\n  /**\n   * Read of a variable in a lexical scope.\n   */\n  LexicalRead,\n\n  /**\n   * A reference to the current view context.\n   */\n  Context,\n\n  /**\n   * Read of a variable declared in a `VariableOp`.\n   */\n  ReadVariable,\n\n  /**\n   * Runtime operation to navigate to the next view context in the view hierarchy.\n   */\n  NextContext,\n\n  /**\n   * Runtime operation to retrieve the value of a local reference.\n   */\n  Reference,\n\n  /**\n   * Runtime operation to snapshot the current view context.\n   */\n  GetCurrentView,\n\n  /**\n   * Runtime operation to restore a snapshotted view.\n   */\n  RestoreView,\n\n  /**\n   * Runtime operation to reset the current view context after `RestoreView`.\n   */\n  ResetView,\n\n  /**\n   * Defines and calls a function with change-detected arguments.\n   */\n  PureFunctionExpr,\n\n  /**\n   * Indicates a positional parameter to a pure function definition.\n   */\n  PureFunctionParameterExpr,\n\n  /**\n   * Binding to a pipe transformation.\n   */\n  PipeBinding,\n\n  /**\n   * Binding to a pipe transformation with a variable number of arguments.\n   */\n  PipeBindingVariadic,\n\n  /*\n   * A safe property read requiring expansion into a null check.\n   */\n  SafePropertyRead,\n\n  /**\n   * A safe keyed read requiring expansion into a null check.\n   */\n  SafeKeyedRead,\n\n  /**\n   * A safe function call requiring expansion into a null check.\n   */\n  SafeInvokeFunction,\n\n  /**\n   * An intermediate expression that will be expanded from a safe read into an explicit ternary.\n   */\n  SafeTernaryExpr,\n\n  /**\n   * An empty expression that will be stipped before generating the final output.\n   */\n  EmptyExpr,\n\n  /*\n   * An assignment to a temporary variable.\n   */\n  AssignTemporaryExpr,\n\n  /**\n   * A reference to a temporary variable.\n   */\n  ReadTemporaryExpr,\n\n  /**\n   * An expression representing a sanitizer function.\n   */\n  SanitizerExpr,\n}\n\n/**\n * Distinguishes between different kinds of `SemanticVariable`s.\n */\nexport enum SemanticVariableKind {\n  /**\n   * Represents the context of a particular view.\n   */\n  Context,\n\n  /**\n   * Represents an identifier declared in the lexical scope of a view.\n   */\n  Identifier,\n\n  /**\n   * Represents a saved state that can be used to restore a view in a listener handler function.\n   */\n  SavedView,\n}\n\n/**\n * Whether to compile in compatibilty mode. In compatibility mode, the template pipeline will\n * attempt to match the output of `TemplateDefinitionBuilder` as exactly as possible, at the cost of\n * producing quirky or larger code in some cases.\n */\nexport enum CompatibilityMode {\n  Normal,\n  TemplateDefinitionBuilder,\n}\n\n/**\n * Represents functions used to sanitize different pieces of a template.\n */\nexport enum SanitizerFn {\n  Html,\n  Script,\n  Style,\n  Url,\n  ResourceUrl,\n  IframeAttribute,\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport type {ParseSourceSpan} from '../../../../parse_util';\nimport type {Op, XrefId} from './operations';\nimport type {Expression} from './expression';\n\n/**\n * Marker symbol for `ConsumesSlotOpTrait`.\n */\nexport const ConsumesSlot = Symbol('ConsumesSlot');\n\n/**\n * Marker symbol for `DependsOnSlotContextOpTrait`.\n */\nexport const DependsOnSlotContext = Symbol('DependsOnSlotContext');\n\n/**\n * Marker symbol for `UsesSlotIndex` trait.\n */\nexport const UsesSlotIndex = Symbol('UsesSlotIndex');\n\n/**\n * Marker symbol for `ConsumesVars` trait.\n */\nexport const ConsumesVarsTrait = Symbol('ConsumesVars');\n\n/**\n * Marker symbol for `UsesVarOffset` trait.\n */\nexport const UsesVarOffset = Symbol('UsesVarOffset');\n\n/**\n * Marks an operation as requiring allocation of one or more data slots for storage.\n */\nexport interface ConsumesSlotOpTrait {\n  readonly[ConsumesSlot]: true;\n\n  /**\n   * Assigned data slot (the starting index, if more than one slot is needed) for this operation, or\n   * `null` if slots have not yet been assigned.\n   */\n  slot: number|null;\n\n  /**\n   * The number of slots which will be used by this operation. By default 1, but can be increased if\n   * necessary.\n   */\n  numSlotsUsed: number;\n\n  /**\n   * `XrefId` of this operation (e.g. the element stored in the assigned slot). This `XrefId` is\n   * used to link this `ConsumesSlotOpTrait` operation with `DependsOnSlotContextTrait` or\n   * `UsesSlotIndexExprTrait` implementors and ensure that the assigned slot is propagated through\n   * the IR to all consumers.\n   */\n  xref: XrefId;\n}\n\n\n/**\n * Marks an operation as depending on the runtime's implicit slot context being set to a particular\n * slot.\n *\n * The runtime has an implicit slot context which is adjusted using the `advance()` instruction\n * during the execution of template update functions. This trait marks an operation as requiring\n * this implicit context to be `advance()`'d to point at a particular slot prior to execution.\n */\nexport interface DependsOnSlotContextOpTrait {\n  readonly[DependsOnSlotContext]: true;\n\n  /**\n   * `XrefId` of the `ConsumesSlotOpTrait` which the implicit slot context must reference before\n   * this operation can be executed.\n   */\n  target: XrefId;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n\n/**\n * Marks an expression which requires knowledge of the assigned slot of a given\n * `ConsumesSlotOpTrait` implementor (e.g. an element slot).\n *\n * During IR processing, assigned slots of `ConsumesSlotOpTrait` implementors will be propagated to\n * `UsesSlotIndexTrait` implementors by matching their `XrefId`s.\n */\nexport interface UsesSlotIndexTrait {\n  readonly[UsesSlotIndex]: true;\n\n  /**\n   * `XrefId` of the `ConsumesSlotOpTrait` which this expression needs to reference by its assigned\n   * slot index.\n   */\n  target: XrefId;\n\n  /**\n   * The slot index of `target`, or `null` if slots have not yet been assigned.\n   */\n  slot: number|null;\n}\n\n/**\n * Marker trait indicating that an operation or expression consumes variable storage space.\n */\nexport interface ConsumesVarsTrait {\n  [ConsumesVarsTrait]: true;\n}\n\n/**\n * Marker trait indicating that an expression requires knowledge of the number of variable storage\n * slots used prior to it.\n */\nexport interface UsesVarOffsetTrait {\n  [UsesVarOffset]: true;\n\n  varOffset: number|null;\n}\n/**\n * Default values for most `ConsumesSlotOpTrait` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_CONSUMES_SLOT: Omit<ConsumesSlotOpTrait, 'xref'> = {\n  [ConsumesSlot]: true,\n  slot: null,\n  numSlotsUsed: 1,\n} as const;\n\n/**\n * Default values for most `UsesSlotIndexTrait` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_USES_SLOT_INDEX: Omit<UsesSlotIndexTrait, 'target'> = {\n  [UsesSlotIndex]: true,\n  slot: null,\n} as const;\n\n/**\n * Default values for most `DependsOnSlotContextOpTrait` fields (used with the spread operator to\n * initialize implementors of the trait).\n */\nexport const TRAIT_DEPENDS_ON_SLOT_CONTEXT:\n    Omit<DependsOnSlotContextOpTrait, 'target'|'sourceSpan'> = {\n      [DependsOnSlotContext]: true,\n    } as const;\n\n/**\n * Default values for `UsesVars` fields (used with the spread operator to initialize\n * implementors of the trait).\n */\nexport const TRAIT_CONSUMES_VARS: ConsumesVarsTrait = {\n  [ConsumesVarsTrait]: true,\n} as const;\n\n/**\n * Default values for `UsesVarOffset` fields (used with the spread operator to initialize\n * implementors of this trait).\n */\nexport const TRAIT_USES_VAR_OFFSET: UsesVarOffsetTrait = {\n  [UsesVarOffset]: true,\n  varOffset: null,\n} as const;\n\n/**\n * Test whether an operation implements `ConsumesSlotOpTrait`.\n */\nexport function hasConsumesSlotTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&ConsumesSlotOpTrait {\n  return (op as Partial<ConsumesSlotOpTrait>)[ConsumesSlot] === true;\n}\n\n/**\n * Test whether an operation implements `DependsOnSlotContextOpTrait`.\n */\nexport function hasDependsOnSlotContextTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&\n    DependsOnSlotContextOpTrait {\n  return (op as Partial<DependsOnSlotContextOpTrait>)[DependsOnSlotContext] === true;\n}\n\n/**\n * Test whether an operation implements `ConsumesVarsTrait`.\n */\nexport function hasConsumesVarsTrait<ExprT extends Expression>(expr: ExprT): expr is ExprT&\n    ConsumesVarsTrait;\nexport function hasConsumesVarsTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&ConsumesVarsTrait;\nexport function hasConsumesVarsTrait(value: any): boolean {\n  return (value as Partial<ConsumesVarsTrait>)[ConsumesVarsTrait] === true;\n}\n\n/**\n * Test whether an expression implements `UsesVarOffsetTrait`.\n */\nexport function hasUsesVarOffsetTrait<ExprT extends Expression>(expr: ExprT): expr is ExprT&\n    UsesVarOffsetTrait {\n  return (expr as Partial<UsesVarOffsetTrait>)[UsesVarOffset] === true;\n}\n\n/**\n * Test whether an operation or expression implements `UsesSlotIndexTrait`.\n */\nexport function hasUsesSlotIndexTrait<ExprT extends Expression>(expr: ExprT): expr is ExprT&\n    UsesSlotIndexTrait;\nexport function hasUsesSlotIndexTrait<OpT extends Op<OpT>>(op: OpT): op is OpT&UsesSlotIndexTrait;\nexport function hasUsesSlotIndexTrait(value: any): boolean {\n  return (value as Partial<UsesSlotIndexTrait>)[UsesSlotIndex] === true;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../../output/output_ast';\nimport {OpKind} from '../enums';\nimport {Op, XrefId} from '../operations';\nimport {SemanticVariable} from '../variable';\n\n/**\n * A special `Op` which is used internally in the `OpList` linked list to represent the head and\n * tail nodes of the list.\n *\n * `ListEndOp` is created internally in the `OpList` and should not be instantiated directly.\n */\nexport interface ListEndOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.ListEnd;\n}\n\n/**\n * An `Op` which directly wraps an output `Statement`.\n *\n * Often `StatementOp`s are the final result of IR processing.\n */\nexport interface StatementOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.Statement;\n\n  /**\n   * The output statement.\n   */\n  statement: o.Statement;\n}\n\n/**\n * Create a `StatementOp`.\n */\nexport function createStatementOp<OpT extends Op<OpT>>(statement: o.Statement): StatementOp<OpT> {\n  return {\n    kind: OpKind.Statement,\n    statement,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Operation which declares and initializes a `SemanticVariable`, that is valid either in create or\n * update IR.\n */\nexport interface VariableOp<OpT extends Op<OpT>> extends Op<OpT> {\n  kind: OpKind.Variable;\n\n  /**\n   * `XrefId` which identifies this specific variable, and is used to reference this variable from\n   * other parts of the IR.\n   */\n  xref: XrefId;\n\n  /**\n   * The `SemanticVariable` which describes the meaning behind this variable.\n   */\n  variable: SemanticVariable;\n\n  /**\n   * Expression representing the value of the variable.\n   */\n  initializer: o.Expression;\n}\n\n/**\n * Create a `VariableOp`.\n */\nexport function createVariableOp<OpT extends Op<OpT>>(\n    xref: XrefId, variable: SemanticVariable, initializer: o.Expression): VariableOp<OpT> {\n  return {\n    kind: OpKind.Variable,\n    xref,\n    variable,\n    initializer,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Static structure shared by all operations.\n *\n * Used as a convenience via the spread operator (`...NEW_OP`) when creating new operations, and\n * ensures the fields are always in the same order.\n */\nexport const NEW_OP: Pick<Op<any>, 'debugListId'|'prev'|'next'> = {\n  debugListId: null,\n  prev: null,\n  next: null,\n};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../../../../../core';\nimport * as o from '../../../../../output/output_ast';\nimport {ParseSourceSpan} from '../../../../../parse_util';\nimport {BindingKind} from '../element';\nimport {OpKind} from '../enums';\nimport {Op, XrefId} from '../operations';\nimport {ConsumesVarsTrait, DependsOnSlotContextOpTrait, TRAIT_CONSUMES_VARS, TRAIT_DEPENDS_ON_SLOT_CONTEXT} from '../traits';\n\nimport type {HostPropertyOp} from './host';\nimport {ListEndOp, NEW_OP, StatementOp, VariableOp} from './shared';\n\n\n/**\n * An operation usable on the update side of the IR.\n */\nexport type UpdateOp =\n    ListEndOp<UpdateOp>|StatementOp<UpdateOp>|PropertyOp|AttributeOp|StylePropOp|ClassPropOp|\n    StyleMapOp|ClassMapOp|InterpolateTextOp|AdvanceOp|VariableOp<UpdateOp>|BindingOp|HostPropertyOp;\n\n/**\n * A logical operation to perform string interpolation on a text node.\n *\n * Interpolation inputs are stored as static `string`s and dynamic `o.Expression`s, in separate\n * arrays. Thus, the interpolation `A{{b}}C{{d}}E` is stored as 3 static strings `['A', 'C', 'E']`\n * and 2 dynamic expressions `[b, d]`.\n */\nexport interface InterpolateTextOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.InterpolateText;\n\n  /**\n   * Reference to the text node to which the interpolation is bound.\n   */\n  target: XrefId;\n\n  interpolation: Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `InterpolationTextOp`.\n */\nexport function createInterpolateTextOp(\n    xref: XrefId, interpolation: Interpolation, sourceSpan: ParseSourceSpan): InterpolateTextOp {\n  return {\n    kind: OpKind.InterpolateText,\n    target: xref,\n    interpolation,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\nexport class Interpolation {\n  constructor(readonly strings: string[], readonly expressions: o.Expression[]) {}\n}\n\n/**\n * An intermediate binding op, that has not yet been processed into an individual property,\n * attribute, style, etc.\n */\nexport interface BindingOp extends Op<UpdateOp> {\n  kind: OpKind.Binding;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   *  The kind of binding represented by this op.\n   */\n  bindingKind: BindingKind;\n\n  /**\n   *  The name of this binding.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression|Interpolation;\n\n  /**\n   * The unit of the bound value.\n   */\n  unit: string|null;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext;\n\n  /**\n   * Whether this binding is on a template.\n   */\n  isTemplate: boolean;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `BindingOp`, not yet transformed into a particular type of binding.\n */\nexport function createBindingOp(\n    target: XrefId, kind: BindingKind, name: string, expression: o.Expression|Interpolation,\n    unit: string|null, securityContext: SecurityContext, isTemplate: boolean,\n    sourceSpan: ParseSourceSpan): BindingOp {\n  return {\n    kind: OpKind.Binding,\n    bindingKind: kind,\n    target,\n    name,\n    expression,\n    unit,\n    securityContext,\n    isTemplate,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a property in the update IR.\n */\nexport interface PropertyOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.Property;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression|Interpolation;\n\n  /**\n   * Whether this property is an animation trigger.\n   */\n  isAnimationTrigger: boolean;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext;\n\n  /**\n   * The sanitizer for this property.\n   */\n  sanitizer: o.Expression|null;\n\n  /**\n   * Whether this binding is on a template.\n   */\n  isTemplate: boolean;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `PropertyOp`.\n */\nexport function createPropertyOp(\n    target: XrefId, name: string, expression: o.Expression|Interpolation,\n    isAnimationTrigger: boolean, securityContext: SecurityContext, isTemplate: boolean,\n\n    sourceSpan: ParseSourceSpan): PropertyOp {\n  return {\n    kind: OpKind.Property,\n    target,\n    name,\n    expression,\n    isAnimationTrigger,\n    securityContext,\n    sanitizer: null,\n    isTemplate,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style property in the update IR.\n */\nexport interface StylePropOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.StyleProp;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression|Interpolation;\n\n  /**\n   * The unit of the bound value.\n   */\n  unit: string|null;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/** Create a `StylePropOp`. */\nexport function createStylePropOp(\n    xref: XrefId, name: string, expression: o.Expression|Interpolation, unit: string|null,\n    sourceSpan: ParseSourceSpan): StylePropOp {\n  return {\n    kind: OpKind.StyleProp,\n    target: xref,\n    name,\n    expression,\n    unit,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a class property in the update IR.\n */\nexport interface ClassPropOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.ClassProp;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Name of the bound property.\n   */\n  name: string;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ClassPropOp`.\n */\nexport function createClassPropOp(\n    xref: XrefId, name: string, expression: o.Expression,\n    sourceSpan: ParseSourceSpan): ClassPropOp {\n  return {\n    kind: OpKind.ClassProp,\n    target: xref,\n    name,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style map in the update IR.\n */\nexport interface StyleMapOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.StyleMap;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression|Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/** Create a `StyleMapOp`. */\nexport function createStyleMapOp(\n    xref: XrefId, expression: o.Expression|Interpolation, sourceSpan: ParseSourceSpan): StyleMapOp {\n  return {\n    kind: OpKind.StyleMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing binding to a style map in the update IR.\n */\nexport interface ClassMapOp extends Op<UpdateOp>, ConsumesVarsTrait, DependsOnSlotContextOpTrait {\n  kind: OpKind.ClassMap;\n\n  /**\n   * Reference to the element on which the property is bound.\n   */\n  target: XrefId;\n\n  /**\n   * Expression which is bound to the property.\n   */\n  expression: o.Expression|Interpolation;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create a `ClassMapOp`.\n */\nexport function createClassMapOp(\n    xref: XrefId, expression: o.Expression|Interpolation, sourceSpan: ParseSourceSpan): ClassMapOp {\n  return {\n    kind: OpKind.ClassMap,\n    target: xref,\n    expression,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * A logical operation representing setting an attribute on an element in the update IR.\n */\nexport interface AttributeOp extends Op<UpdateOp> {\n  kind: OpKind.Attribute;\n\n  /**\n   * The `XrefId` of the template-like element the attribute will belong to.\n   */\n  target: XrefId;\n\n  /**\n   * The name of the attribute.\n   */\n  name: string;\n\n  /**\n   * The value of the attribute.\n   */\n  expression: o.Expression|Interpolation;\n\n  /**\n   * The security context of the binding.\n   */\n  securityContext: SecurityContext;\n\n  /**\n   * The sanitizer for this attribute.\n   */\n  sanitizer: o.Expression|null;\n\n  /**\n   * Whether this binding is on a template.\n   */\n  isTemplate: boolean;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AttributeOp`.\n */\nexport function createAttributeOp(\n    target: XrefId, name: string, expression: o.Expression|Interpolation,\n    securityContext: SecurityContext, isTemplate: boolean,\n    sourceSpan: ParseSourceSpan): AttributeOp {\n  return {\n    kind: OpKind.Attribute,\n    target,\n    name,\n    expression,\n    securityContext,\n    sanitizer: null,\n    isTemplate,\n    sourceSpan,\n    ...TRAIT_DEPENDS_ON_SLOT_CONTEXT,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation to advance the runtime's internal slot pointer in the update IR.\n */\nexport interface AdvanceOp extends Op<UpdateOp> {\n  kind: OpKind.Advance;\n\n  /**\n   * Delta by which to advance the pointer.\n   */\n  delta: number;\n\n  // Source span of the binding that caused the advance\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Create an `AdvanceOp`.\n */\nexport function createAdvanceOp(delta: number, sourceSpan: ParseSourceSpan): AdvanceOp {\n  return {\n    kind: OpKind.Advance,\n    delta,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport type {ParseSourceSpan} from '../../../../parse_util';\n\nimport {ExpressionKind, OpKind, SanitizerFn} from './enums';\nimport {ConsumesVarsTrait, UsesSlotIndex, UsesSlotIndexTrait, UsesVarOffset, UsesVarOffsetTrait} from './traits';\n\nimport type {XrefId} from './operations';\nimport type {CreateOp} from './ops/create';\nimport {Interpolation, type UpdateOp} from './ops/update';\n\n/**\n * An `o.Expression` subtype representing a logical expression in the intermediate representation.\n */\nexport type Expression =\n    LexicalReadExpr|ReferenceExpr|ContextExpr|NextContextExpr|GetCurrentViewExpr|RestoreViewExpr|\n    ResetViewExpr|ReadVariableExpr|PureFunctionExpr|PureFunctionParameterExpr|PipeBindingExpr|\n    PipeBindingVariadicExpr|SafePropertyReadExpr|SafeKeyedReadExpr|SafeInvokeFunctionExpr|EmptyExpr|\n    AssignTemporaryExpr|ReadTemporaryExpr|SanitizerExpr;\n\n/**\n * Transformer type which converts expressions into general `o.Expression`s (which may be an\n * identity transformation).\n */\nexport type ExpressionTransform = (expr: o.Expression, flags: VisitorContextFlag) => o.Expression;\n\n/**\n * Check whether a given `o.Expression` is a logical IR expression type.\n */\nexport function isIrExpression(expr: o.Expression): expr is Expression {\n  return expr instanceof ExpressionBase;\n}\n\n/**\n * Base type used for all logical IR expressions.\n */\nexport abstract class ExpressionBase extends o.Expression {\n  abstract readonly kind: ExpressionKind;\n\n  constructor(sourceSpan: ParseSourceSpan|null = null) {\n    super(null, sourceSpan);\n  }\n\n  /**\n   * Run the transformer against any nested expressions which may be present in this IR expression\n   * subtype.\n   */\n  abstract transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void;\n}\n\n/**\n * Logical expression representing a lexical read of a variable name.\n */\nexport class LexicalReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.LexicalRead;\n\n  constructor(readonly name: string) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {}\n\n  overrideÂ isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): LexicalReadExpr {\n    return new LexicalReadExpr(this.name);\n  }\n}\n\n/**\n * Runtime operation to retrieve the value of a local reference.\n */\nexport class ReferenceExpr extends ExpressionBase implements UsesSlotIndexTrait {\n  override readonly kind = ExpressionKind.Reference;\n\n  readonly[UsesSlotIndex] = true;\n\n  slot: number|null = null;\n\n  constructor(readonly target: XrefId, readonly offset: number) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ReferenceExpr && e.target === this.target;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ReferenceExpr {\n    const expr = new ReferenceExpr(this.target, this.offset);\n    expr.slot = this.slot;\n    return expr;\n  }\n}\n\n/**\n * A reference to the current view context (usually the `ctx` variable in a template function).\n */\nexport class ContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.Context;\n\n  constructor(readonly view: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ContextExpr && e.view === this.view;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ContextExpr {\n    return new ContextExpr(this.view);\n  }\n}\n\n/**\n * Runtime operation to navigate to the next view context in the view hierarchy.\n */\nexport class NextContextExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.NextContext;\n\n  steps = 1;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof NextContextExpr && e.steps === this.steps;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): NextContextExpr {\n    const expr = new NextContextExpr();\n    expr.steps = this.steps;\n    return expr;\n  }\n}\n\n/**\n * Runtime operation to snapshot the current view context.\n *\n * The result of this operation can be stored in a variable and later used with the `RestoreView`\n * operation.\n */\nexport class GetCurrentViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.GetCurrentView;\n\n  constructor() {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof GetCurrentViewExpr;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): GetCurrentViewExpr {\n    return new GetCurrentViewExpr();\n  }\n}\n\n/**\n * Runtime operation to restore a snapshotted view.\n */\nexport class RestoreViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.RestoreView;\n\n  constructor(public view: XrefId|o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    if (typeof this.view !== 'number') {\n      this.view.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    if (!(e instanceof RestoreViewExpr) || typeof e.view !== typeof this.view) {\n      return false;\n    }\n\n    if (typeof this.view === 'number') {\n      return this.view === e.view;\n    } else {\n      return this.view.isEquivalent(e.view as o.Expression);\n    }\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    if (typeof this.view !== 'number') {\n      this.view = transformExpressionsInExpression(this.view, transform, flags);\n    }\n  }\n\n  override clone(): RestoreViewExpr {\n    return new RestoreViewExpr(this.view instanceof o.Expression ? this.view.clone() : this.view);\n  }\n}\n\n/**\n * Runtime operation to reset the current view context after `RestoreView`.\n */\nexport class ResetViewExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ResetView;\n\n  constructor(public expr: o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(e: o.Expression): boolean {\n    return e instanceof ResetViewExpr && this.expr.isEquivalent(e.expr);\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): ResetViewExpr {\n    return new ResetViewExpr(this.expr.clone());\n  }\n}\n\n/**\n * Read of a variable declared as an `ir.VariableOp` and referenced through its `ir.XrefId`.\n */\nexport class ReadVariableExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ReadVariable;\n  name: string|null = null;\n  constructor(readonly xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(other: o.Expression): boolean {\n    return other instanceof ReadVariableExpr && other.xref === this.xref;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): ReadVariableExpr {\n    const expr = new ReadVariableExpr(this.xref);\n    expr.name = this.name;\n    return expr;\n  }\n}\n\nexport class PureFunctionExpr extends ExpressionBase implements ConsumesVarsTrait,\n                                                                UsesVarOffsetTrait {\n  override readonly kind = ExpressionKind.PureFunctionExpr;\n  readonly[ConsumesVarsTrait] = true;\n  readonly[UsesVarOffset] = true;\n\n  varOffset: number|null = null;\n\n  /**\n   * The expression which should be memoized as a pure computation.\n   *\n   * This expression contains internal `PureFunctionParameterExpr`s, which are placeholders for the\n   * positional argument expressions in `args.\n   */\n  body: o.Expression|null;\n\n  /**\n   * Positional arguments to the pure function which will memoize the `body` expression, which act\n   * as memoization keys.\n   */\n  args: o.Expression[];\n\n  /**\n   * Once extracted to the `ConstantPool`, a reference to the function which defines the computation\n   * of `body`.\n   */\n  fn: o.Expression|null = null;\n\n  constructor(expression: o.Expression|null, args: o.Expression[]) {\n    super();\n    this.body = expression;\n    this.args = args;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any) {\n    this.body?.visitExpression(visitor, context);\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(other: o.Expression): boolean {\n    if (!(other instanceof PureFunctionExpr) || other.args.length !== this.args.length) {\n      return false;\n    }\n\n    return other.body !== null && this.body !== null && other.body.isEquivalent(this.body) &&\n        other.args.every((arg, idx) => arg.isEquivalent(this.args[idx]));\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    if (this.body !== null) {\n      // TODO: figure out if this is the right flag to pass here.\n      this.body = transformExpressionsInExpression(\n          this.body, transform, flags | VisitorContextFlag.InChildOperation);\n    } else if (this.fn !== null) {\n      this.fn = transformExpressionsInExpression(this.fn, transform, flags);\n    }\n\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n\n  override clone(): PureFunctionExpr {\n    const expr =\n        new PureFunctionExpr(this.body?.clone() ?? null, this.args.map(arg => arg.clone()));\n    expr.fn = this.fn?.clone() ?? null;\n    expr.varOffset = this.varOffset;\n    return expr;\n  }\n}\n\nexport class PureFunctionParameterExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.PureFunctionParameterExpr;\n\n  constructor(public index: number) {\n    super();\n  }\n\n  override visitExpression(): void {}\n\n  override isEquivalent(other: o.Expression): boolean {\n    return other instanceof PureFunctionParameterExpr && other.index === this.index;\n  }\n\n  override isConstant(): boolean {\n    return true;\n  }\n\n  override transformInternalExpressions(): void {}\n\n  override clone(): PureFunctionParameterExpr {\n    return new PureFunctionParameterExpr(this.index);\n  }\n}\n\nexport class PipeBindingExpr extends ExpressionBase implements UsesSlotIndexTrait,\n                                                               ConsumesVarsTrait,\n                                                               UsesVarOffsetTrait {\n  override readonly kind = ExpressionKind.PipeBinding;\n  readonly[UsesSlotIndex] = true;\n  readonly[ConsumesVarsTrait] = true;\n  readonly[UsesVarOffset] = true;\n\n  slot: number|null = null;\n  varOffset: number|null = null;\n\n  constructor(readonly target: XrefId, readonly name: string, readonly args: o.Expression[]) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    for (const arg of this.args) {\n      arg.visitExpression(visitor, context);\n    }\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    for (let idx = 0; idx < this.args.length; idx++) {\n      this.args[idx] = transformExpressionsInExpression(this.args[idx], transform, flags);\n    }\n  }\n\n  override clone() {\n    const r = new PipeBindingExpr(this.target, this.name, this.args.map(a => a.clone()));\n    r.slot = this.slot;\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\n\nexport class PipeBindingVariadicExpr extends ExpressionBase implements UsesSlotIndexTrait,\n                                                                       ConsumesVarsTrait,\n                                                                       UsesVarOffsetTrait {\n  override readonly kind = ExpressionKind.PipeBindingVariadic;\n  readonly[UsesSlotIndex] = true;\n  readonly[ConsumesVarsTrait] = true;\n  readonly[UsesVarOffset] = true;\n\n  slot: number|null = null;\n  varOffset: number|null = null;\n\n  constructor(\n      readonly target: XrefId, readonly name: string, public args: o.Expression,\n      public numArgs: number) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): void {\n    this.args.visitExpression(visitor, context);\n  }\n\n  override isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.args = transformExpressionsInExpression(this.args, transform, flags);\n  }\n\n  override clone(): PipeBindingVariadicExpr {\n    const r = new PipeBindingVariadicExpr(this.target, this.name, this.args.clone(), this.numArgs);\n    r.slot = this.slot;\n    r.varOffset = this.varOffset;\n    return r;\n  }\n}\n\nexport class SafePropertyReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafePropertyRead;\n\n  constructor(public receiver: o.Expression, public name: string) {\n    super();\n  }\n\n  // An alias for name, which allows other logic to handle property reads and keyed reads together.\n  get index() {\n    return this.name;\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n  }\n\n  overrideÂ isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n  }\n\n  override clone(): SafePropertyReadExpr {\n    return new SafePropertyReadExpr(this.receiver.clone(), this.name);\n  }\n}\n\nexport class SafeKeyedReadExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeKeyedRead;\n\n  constructor(public receiver: o.Expression, public index: o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n    this.index.visitExpression(visitor, context);\n  }\n\n  overrideÂ isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    this.index = transformExpressionsInExpression(this.index, transform, flags);\n  }\n\n  override clone(): SafeKeyedReadExpr {\n    return new SafeKeyedReadExpr(this.receiver.clone(), this.index.clone());\n  }\n}\n\nexport class SafeInvokeFunctionExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeInvokeFunction;\n\n  constructor(public receiver: o.Expression, public args: o.Expression[]) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.receiver.visitExpression(visitor, context);\n    for (const a of this.args) {\n      a.visitExpression(visitor, context);\n    }\n  }\n\n  overrideÂ isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.receiver = transformExpressionsInExpression(this.receiver, transform, flags);\n    for (let i = 0; i < this.args.length; i++) {\n      this.args[i] = transformExpressionsInExpression(this.args[i], transform, flags);\n    }\n  }\n\n  override clone(): SafeInvokeFunctionExpr {\n    return new SafeInvokeFunctionExpr(this.receiver.clone(), this.args.map(a => a.clone()));\n  }\n}\n\nexport class SafeTernaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SafeTernaryExpr;\n\n  constructor(public guard: o.Expression, public expr: o.Expression) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.guard.visitExpression(visitor, context);\n    this.expr.visitExpression(visitor, context);\n  }\n\n  overrideÂ isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.guard = transformExpressionsInExpression(this.guard, transform, flags);\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): SafeTernaryExpr {\n    return new SafeTernaryExpr(this.guard.clone(), this.expr.clone());\n  }\n}\n\nexport class EmptyExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.EmptyExpr;\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof EmptyExpr;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): EmptyExpr {\n    return new EmptyExpr();\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\nexport class AssignTemporaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.AssignTemporaryExpr;\n\n  public name: string|null = null;\n\n  constructor(public expr: o.Expression, public xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    this.expr.visitExpression(visitor, context);\n  }\n\n  overrideÂ isEquivalent(): boolean {\n    return false;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {\n    this.expr = transformExpressionsInExpression(this.expr, transform, flags);\n  }\n\n  override clone(): AssignTemporaryExpr {\n    const a = new AssignTemporaryExpr(this.expr.clone(), this.xref);\n    a.name = this.name;\n    return a;\n  }\n}\n\nexport class ReadTemporaryExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.ReadTemporaryExpr;\n\n  public name: string|null = null;\n\n  constructor(public xref: XrefId) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  overrideÂ isEquivalent(): boolean {\n    return this.xref === this.xref;\n  }\n\n  override isConstant(): boolean {\n    return false;\n  }\n\n  override transformInternalExpressions(transform: ExpressionTransform, flags: VisitorContextFlag):\n      void {}\n\n  override clone(): ReadTemporaryExpr {\n    const r = new ReadTemporaryExpr(this.xref);\n    r.name = this.name;\n    return r;\n  }\n}\n\nexport class SanitizerExpr extends ExpressionBase {\n  override readonly kind = ExpressionKind.SanitizerExpr;\n\n  constructor(public fn: SanitizerFn) {\n    super();\n  }\n\n  override visitExpression(visitor: o.ExpressionVisitor, context: any): any {}\n\n  override isEquivalent(e: Expression): boolean {\n    return e instanceof SanitizerExpr && e.fn === this.fn;\n  }\n\n  override isConstant() {\n    return true;\n  }\n\n  override clone(): SanitizerExpr {\n    return new SanitizerExpr(this.fn);\n  }\n\n  override transformInternalExpressions(): void {}\n}\n\n/**\n * Visits all `Expression`s in the AST of `op` with the `visitor` function.\n */\nexport function visitExpressionsInOp(\n    op: CreateOp|UpdateOp, visitor: (expr: o.Expression, flags: VisitorContextFlag) => void): void {\n  transformExpressionsInOp(op, (expr, flags) => {\n    visitor(expr, flags);\n    return expr;\n  }, VisitorContextFlag.None);\n}\n\nexport enum VisitorContextFlag {\n  None = 0b0000,\n  InChildOperation = 0b0001,\n}\n\nfunction transformExpressionsInInterpolation(\n    interpolation: Interpolation, transform: ExpressionTransform, flags: VisitorContextFlag) {\n  for (let i = 0; i < interpolation.expressions.length; i++) {\n    interpolation.expressions[i] =\n        transformExpressionsInExpression(interpolation.expressions[i], transform, flags);\n  }\n}\n\n/**\n * Transform all `Expression`s in the AST of `op` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInOp(\n    op: CreateOp|UpdateOp, transform: ExpressionTransform, flags: VisitorContextFlag): void {\n  switch (op.kind) {\n    case OpKind.StyleProp:\n    case OpKind.StyleMap:\n    case OpKind.ClassProp:\n    case OpKind.ClassMap:\n    case OpKind.Binding:\n    case OpKind.HostProperty:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      break;\n    case OpKind.Property:\n    case OpKind.Attribute:\n      if (op.expression instanceof Interpolation) {\n        transformExpressionsInInterpolation(op.expression, transform, flags);\n      } else {\n        op.expression = transformExpressionsInExpression(op.expression, transform, flags);\n      }\n      op.sanitizer =\n          op.sanitizer && transformExpressionsInExpression(op.sanitizer, transform, flags);\n      break;\n    case OpKind.InterpolateText:\n      transformExpressionsInInterpolation(op.interpolation, transform, flags);\n      break;\n    case OpKind.Statement:\n      transformExpressionsInStatement(op.statement, transform, flags);\n      break;\n    case OpKind.Variable:\n      op.initializer = transformExpressionsInExpression(op.initializer, transform, flags);\n      break;\n    case OpKind.Listener:\n      for (const innerOp of op.handlerOps) {\n        transformExpressionsInOp(innerOp, transform, flags | VisitorContextFlag.InChildOperation);\n      }\n      break;\n    case OpKind.Element:\n    case OpKind.ElementStart:\n    case OpKind.ElementEnd:\n    case OpKind.Container:\n    case OpKind.ContainerStart:\n    case OpKind.ContainerEnd:\n    case OpKind.Template:\n    case OpKind.DisableBindings:\n    case OpKind.EnableBindings:\n    case OpKind.Text:\n    case OpKind.Pipe:\n    case OpKind.Advance:\n    case OpKind.Namespace:\n      // These operations contain no expressions.\n      break;\n    default:\n      throw new Error(`AssertionError: transformExpressionsInOp doesn't handle ${OpKind[op.kind]}`);\n  }\n}\n\n/**\n * Transform all `Expression`s in the AST of `expr` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInExpression(\n    expr: o.Expression, transform: ExpressionTransform, flags: VisitorContextFlag): o.Expression {\n  if (expr instanceof ExpressionBase) {\n    expr.transformInternalExpressions(transform, flags);\n  } else if (expr instanceof o.BinaryOperatorExpr) {\n    expr.lhs = transformExpressionsInExpression(expr.lhs, transform, flags);\n    expr.rhs = transformExpressionsInExpression(expr.rhs, transform, flags);\n  } else if (expr instanceof o.ReadPropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n  } else if (expr instanceof o.ReadKeyExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.index = transformExpressionsInExpression(expr.index, transform, flags);\n  } else if (expr instanceof o.WritePropExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.value = transformExpressionsInExpression(expr.value, transform, flags);\n  } else if (expr instanceof o.WriteKeyExpr) {\n    expr.receiver = transformExpressionsInExpression(expr.receiver, transform, flags);\n    expr.index = transformExpressionsInExpression(expr.index, transform, flags);\n    expr.value = transformExpressionsInExpression(expr.value, transform, flags);\n  } else if (expr instanceof o.InvokeFunctionExpr) {\n    expr.fn = transformExpressionsInExpression(expr.fn, transform, flags);\n    for (let i = 0; i < expr.args.length; i++) {\n      expr.args[i] = transformExpressionsInExpression(expr.args[i], transform, flags);\n    }\n  } else if (expr instanceof o.LiteralArrayExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i] = transformExpressionsInExpression(expr.entries[i], transform, flags);\n    }\n  } else if (expr instanceof o.LiteralMapExpr) {\n    for (let i = 0; i < expr.entries.length; i++) {\n      expr.entries[i].value =\n          transformExpressionsInExpression(expr.entries[i].value, transform, flags);\n    }\n  } else if (expr instanceof o.ConditionalExpr) {\n    expr.condition = transformExpressionsInExpression(expr.condition, transform, flags);\n    expr.trueCase = transformExpressionsInExpression(expr.trueCase, transform, flags);\n    if (expr.falseCase !== null) {\n      expr.falseCase = transformExpressionsInExpression(expr.falseCase, transform, flags);\n    }\n  } else if (\n      expr instanceof o.ReadVarExpr || expr instanceof o.ExternalExpr ||\n      expr instanceof o.LiteralExpr) {\n    // No action for these types.\n  } else {\n    throw new Error(`Unhandled expression kind: ${expr.constructor.name}`);\n  }\n  return transform(expr, flags);\n}\n\n/**\n * Transform all `Expression`s in the AST of `stmt` with the `transform` function.\n *\n * All such operations will be replaced with the result of applying `transform`, which may be an\n * identity transformation.\n */\nexport function transformExpressionsInStatement(\n    stmt: o.Statement, transform: ExpressionTransform, flags: VisitorContextFlag): void {\n  if (stmt instanceof o.ExpressionStatement) {\n    stmt.expr = transformExpressionsInExpression(stmt.expr, transform, flags);\n  } else if (stmt instanceof o.ReturnStatement) {\n    stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n  } else if (stmt instanceof o.DeclareVarStmt) {\n    if (stmt.value !== undefined) {\n      stmt.value = transformExpressionsInExpression(stmt.value, transform, flags);\n    }\n  } else {\n    throw new Error(`Unhandled statement kind: ${stmt.constructor.name}`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {OpKind} from './enums';\n\n/**\n * Branded type for a cross-reference ID. During ingest, `XrefId`s are generated to link together\n * different IR operations which need to reference each other.\n */\nexport type XrefId = number&{__brand: 'XrefId'};\n\n/**\n * Base interface for semantic operations being performed within a template.\n *\n * @param OpT a specific narrower type of `Op` (for example, creation operations) which this\n *     specific subtype of `Op` can be linked with in a linked list.\n */\nexport interface Op<OpT extends Op<OpT>> {\n  /**\n   * All operations have a distinct kind.\n   */\n  kind: OpKind;\n\n  /**\n   * The previous operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  prev: OpT|null;\n\n  /**\n   * The next operation in the linked list, if any.\n   *\n   * This is `null` for operation nodes not currently in a list, or for the special head/tail nodes.\n   */\n  next: OpT|null;\n\n  /**\n   * Debug id of the list to which this node currently belongs, or `null` if this node is not part\n   * of a list.\n   */\n  debugListId: number|null;\n}\n\n/**\n * A linked list of `Op` nodes of a given subtype.\n *\n * @param OpT specific subtype of `Op` nodes which this list contains.\n */\nexport class OpList<OpT extends Op<OpT>> {\n  static nextListId = 0;\n\n  /**\n   * Debug ID of this `OpList` instance.\n   */\n  readonly debugListId = OpList.nextListId++;\n\n  // OpList uses static head/tail nodes of a special `ListEnd` type.\n  // This avoids the need for special casing of the first and last list\n  // elements in all list operations.\n  readonly head: OpT = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n  readonly tail = {\n    kind: OpKind.ListEnd,\n    next: null,\n    prev: null,\n    debugListId: this.debugListId,\n  } as OpT;\n\n\n  constructor() {\n    // Link `head` and `tail` together at the start (list is empty).\n    this.head.next = this.tail;\n    this.tail.prev = this.head;\n  }\n\n  /**\n   * Push a new operation to the tail of the list.\n   */\n  push(op: OpT): void {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = this.debugListId;\n\n    // The old \"previous\" node (which might be the head, if the list is empty).\n    const oldLast = this.tail.prev!;\n\n    // Insert `op` following the old last node.\n    op.prev = oldLast;\n    oldLast.next = op;\n\n    // Connect `op` with the list tail.\n    op.next = this.tail;\n    this.tail.prev = op;\n  }\n\n  /**\n   * Prepend one or more nodes to the start of the list.\n   */\n  prepend(ops: OpT[]): void {\n    if (ops.length === 0) {\n      return;\n    }\n\n    for (const op of ops) {\n      OpList.assertIsNotEnd(op);\n      OpList.assertIsUnowned(op);\n\n      op.debugListId = this.debugListId;\n    }\n\n    const first = this.head.next!;\n\n    let prev = this.head;\n    for (const op of ops) {\n      prev.next = op;\n      op.prev = prev;\n\n      prev = op;\n    }\n\n    prev.next = first;\n    first.prev = prev;\n  }\n\n  /**\n   * `OpList` is iterable via the iteration protocol.\n   *\n   * It's safe to mutate the part of the list that has already been returned by the iterator, up to\n   * and including the last operation returned. Mutations beyond that point _may_ be safe, but may\n   * also corrupt the iteration position and should be avoided.\n   */\n  * [Symbol.iterator](): Generator<OpT> {\n    let current = this.head.next!;\n    while (current !== this.tail) {\n      // Guards against corruption of the iterator state by mutations to the tail of the list during\n      // iteration.\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const next = current.next!;\n      yield current;\n      current = next;\n    }\n  }\n\n  * reversed(): Generator<OpT> {\n    let current = this.tail.prev!;\n    while (current !== this.head) {\n      OpList.assertIsOwned(current, this.debugListId);\n\n      const prev = current.prev!;\n      yield current;\n      current = prev;\n    }\n  }\n\n  /**\n   * Replace `oldOp` with `newOp` in the list.\n   */\n  static replace<OpT extends Op<OpT>>(oldOp: OpT, newOp: OpT): void {\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsNotEnd(newOp);\n\n    OpList.assertIsOwned(oldOp);\n    OpList.assertIsUnowned(newOp);\n\n    newOp.debugListId = oldOp.debugListId;\n    if (oldOp.prev !== null) {\n      oldOp.prev.next = newOp;\n      newOp.prev = oldOp.prev;\n    }\n    if (oldOp.next !== null) {\n      oldOp.next.prev = newOp;\n      newOp.next = oldOp.next;\n    }\n    oldOp.debugListId = null;\n    oldOp.prev = null;\n    oldOp.next = null;\n  }\n\n  /**\n   * Replace `oldOp` with some number of new operations in the list (which may include `oldOp`).\n   */\n  static replaceWithMany<OpT extends Op<OpT>>(oldOp: OpT, newOps: OpT[]): void {\n    if (newOps.length === 0) {\n      // Replacing with an empty list -> pure removal.\n      OpList.remove(oldOp);\n      return;\n    }\n\n    OpList.assertIsNotEnd(oldOp);\n    OpList.assertIsOwned(oldOp);\n\n    const listId = oldOp.debugListId;\n    oldOp.debugListId = null;\n\n    for (const newOp of newOps) {\n      OpList.assertIsNotEnd(newOp);\n\n      // `newOp` might be `oldOp`, but at this point it's been marked as unowned.\n      OpList.assertIsUnowned(newOp);\n    }\n\n    // It should be safe to reuse `oldOp` in the `newOps` list - maybe you want to sandwich an\n    // operation between two new ops.\n    const {prev: oldPrev, next: oldNext} = oldOp;\n    oldOp.prev = null;\n    oldOp.next = null;\n\n    let prev: OpT = oldPrev!;\n    for (const newOp of newOps) {\n      this.assertIsUnowned(newOp);\n      newOp.debugListId = listId;\n\n      prev!.next = newOp;\n      newOp.prev = prev;\n\n      // This _should_ be the case, but set it just in case.\n      newOp.next = null;\n\n      prev = newOp;\n    }\n    // At the end of iteration, `prev` holds the last node in the list.\n    const first = newOps[0]!;\n    const last = prev!;\n\n    // Replace `oldOp` with the chain `first` -> `last`.\n    if (oldPrev !== null) {\n      oldPrev.next = first;\n      first.prev = oldOp.prev;\n    }\n\n    if (oldNext !== null) {\n      oldNext.prev = last;\n      last.next = oldNext;\n    }\n  }\n\n  /**\n   * Remove the given node from the list which contains it.\n   */\n  static remove<OpT extends Op<OpT>>(op: OpT): void {\n    OpList.assertIsNotEnd(op);\n    OpList.assertIsOwned(op);\n\n    op.prev!.next = op.next;\n    op.next!.prev = op.prev;\n\n    // Break any link between the node and this list to safeguard against its usage in future\n    // operations.\n    op.debugListId = null;\n    op.prev = null;\n    op.next = null;\n  }\n\n  /**\n   * Insert `op` before `target`.\n   */\n  static insertBefore<OpT extends Op<OpT>>(op: OpT, target: OpT): void {\n    OpList.assertIsOwned(target);\n    if (target.prev === null) {\n      throw new Error(`AssertionError: illegal operation on list start`);\n    }\n\n    OpList.assertIsNotEnd(op);\n\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = target.debugListId;\n\n    // Just in case.\n    op.prev = null;\n\n    target.prev!.next = op;\n    op.prev = target.prev;\n\n    op.next = target;\n    target.prev = op;\n  }\n\n  /**\n   * Insert `op` after `target`.\n   */\n  static insertAfter<OpT extends Op<OpT>>(op: OpT, target: OpT): void {\n    OpList.assertIsOwned(target);\n    if (target.next === null) {\n      throw new Error(`AssertionError: illegal operation on list end`);\n    }\n\n    OpList.assertIsNotEnd(op);\n\n    OpList.assertIsUnowned(op);\n\n    op.debugListId = target.debugListId;\n\n    target.next.prev = op;\n    op.next = target.next;\n\n    op.prev = target;\n    target.next = op;\n  }\n\n  /**\n   * Asserts that `op` does not currently belong to a list.\n   */\n  static assertIsUnowned<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.debugListId !== null) {\n      throw new Error(`AssertionError: illegal operation on owned node: ${OpKind[op.kind]}`);\n    }\n  }\n\n  /**\n   * Asserts that `op` currently belongs to a list. If `byList` is passed, `op` is asserted to\n   * specifically belong to that list.\n   */\n  static assertIsOwned<OpT extends Op<OpT>>(op: OpT, byList?: number): void {\n    if (op.debugListId === null) {\n      throw new Error(`AssertionError: illegal operation on unowned node: ${OpKind[op.kind]}`);\n    } else if (byList !== undefined && op.debugListId !== byList) {\n      throw new Error(`AssertionError: node belongs to the wrong list (expected ${byList}, actual ${\n          op.debugListId})`);\n    }\n  }\n\n  /**\n   * Asserts that `op` is not a special `ListEnd` node.\n   */\n  static assertIsNotEnd<OpT extends Op<OpT>>(op: OpT): void {\n    if (op.kind === OpKind.ListEnd) {\n      throw new Error(`AssertionError: illegal operation on list head or tail`);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../../../../../parse_util';\nimport {ElementAttributes} from '../element';\nimport {OpKind} from '../enums';\nimport {Op, OpList, XrefId} from '../operations';\nimport {ConsumesSlotOpTrait, TRAIT_CONSUMES_SLOT, TRAIT_USES_SLOT_INDEX, UsesSlotIndexTrait} from '../traits';\n\nimport {ListEndOp, NEW_OP, StatementOp, VariableOp} from './shared';\n\nimport type {UpdateOp} from './update';\n\n/**\n * An operation usable on the creation side of the IR.\n */\nexport type CreateOp = ListEndOp<CreateOp>|StatementOp<CreateOp>|ElementOp|ElementStartOp|\n    ElementEndOp|ContainerOp|ContainerStartOp|ContainerEndOp|TemplateOp|EnableBindingsOp|\n    DisableBindingsOp|TextOp|ListenerOp|PipeOp|VariableOp<CreateOp>|NamespaceOp;\n\n/**\n * An operation representing the creation of an element or container.\n */\nexport type ElementOrContainerOps =\n    ElementOp|ElementStartOp|ContainerOp|ContainerStartOp|TemplateOp;\n\n/**\n * The set of OpKinds that represent the creation of an element or container\n */\nconst elementContainerOpKinds = new Set([\n  OpKind.Element, OpKind.ElementStart, OpKind.Container, OpKind.ContainerStart, OpKind.Template\n]);\n\n/**\n * Checks whether the given operation represents the creation of an element or container.\n */\nexport function isElementOrContainerOp(op: CreateOp): op is ElementOrContainerOps {\n  return elementContainerOpKinds.has(op.kind);\n}\n\n/**\n * Representation of a local reference on an element.\n */\nexport interface LocalRef {\n  /**\n   * User-defined name of the local ref variable.\n   */\n  name: string;\n\n  /**\n   * Target of the local reference variable (often `''`).\n   */\n  target: string;\n}\n\n/**\n * Base interface for `Element`, `ElementStart`, and `Template` operations, containing common fields\n * used to represent their element-like nature.\n */\nexport interface ElementOrContainerOpBase extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: ElementOrContainerOps['kind'];\n\n  /**\n   * `XrefId` allocated for this element.\n   *\n   * This ID is used to reference this element from other IR structures.\n   */\n  xref: XrefId;\n\n  /**\n   * Attributes of various kinds on this element.\n   *\n   * Before attribute processing, this is an `ElementAttributes` structure representing the\n   * attributes on this element.\n   *\n   * After processing, it's a `ConstIndex` pointer into the shared `consts` array of the component\n   * compilation.\n   */\n  attributes: ElementAttributes|ConstIndex|null;\n\n  /**\n   * Local references to this element.\n   *\n   * Before local ref processing, this is an array of `LocalRef` declarations.\n   *\n   * After processing, it's a `ConstIndex` pointer into the shared `consts` array of the component\n   * compilation.\n   */\n  localRefs: LocalRef[]|ConstIndex|null;\n\n  /**\n   * Whether this container is marked `ngNonBindable`, which disabled Angular binding for itself and\n   * all descendants.\n   */\n  nonBindable: boolean;\n\n  sourceSpan: ParseSourceSpan;\n}\n\nexport interface ElementOpBase extends ElementOrContainerOpBase {\n  kind: OpKind.Element|OpKind.ElementStart|OpKind.Template;\n\n  /**\n   * The HTML tag name for this element.\n   */\n  tag: string;\n\n  /**\n   * The namespace of this element, which controls the preceding namespace instruction.\n   */\n  namespace: Namespace;\n}\n\n/**\n * Logical operation representing the start of an element in the creation IR.\n */\nexport interface ElementStartOp extends ElementOpBase {\n  kind: OpKind.ElementStart;\n}\n\n/**\n * Create an `ElementStartOp`.\n */\nexport function createElementStartOp(\n    tag: string, xref: XrefId, namespace: Namespace, sourceSpan: ParseSourceSpan): ElementStartOp {\n  return {\n    kind: OpKind.ElementStart,\n    xref,\n    tag,\n    attributes: new ElementAttributes(),\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    sourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing an element with no children in the creation IR.\n */\nexport interface ElementOp extends ElementOpBase {\n  kind: OpKind.Element;\n}\n\n/**\n * Logical operation representing an embedded view declaration in the creation IR.\n */\nexport interface TemplateOp extends ElementOpBase {\n  kind: OpKind.Template;\n\n  /**\n   * The number of declaration slots used by this template, or `null` if slots have not yet been\n   * assigned.\n   */\n  decls: number|null;\n\n  /**\n   * The number of binding variable slots used by this template, or `null` if binding variables have\n   * not yet been counted.\n   */\n  vars: number|null;\n}\n\n/**\n * Create a `TemplateOp`.\n */\nexport function createTemplateOp(\n    xref: XrefId, tag: string, namespace: Namespace, sourceSpan: ParseSourceSpan): TemplateOp {\n  return {\n    kind: OpKind.Template,\n    xref,\n    attributes: new ElementAttributes(),\n    tag,\n    decls: null,\n    vars: null,\n    localRefs: [],\n    nonBindable: false,\n    namespace,\n    sourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing the end of an element structure in the creation IR.\n *\n * Pairs with an `ElementStart` operation.\n */\nexport interface ElementEndOp extends Op<CreateOp> {\n  kind: OpKind.ElementEnd;\n\n  /**\n   * The `XrefId` of the element declared via `ElementStart`.\n   */\n  xref: XrefId;\n\n  sourceSpan: ParseSourceSpan|null;\n}\n\n/**\n * Create an `ElementEndOp`.\n */\nexport function createElementEndOp(xref: XrefId, sourceSpan: ParseSourceSpan|null): ElementEndOp {\n  return {\n    kind: OpKind.ElementEnd,\n    xref,\n    sourceSpan,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing the start of a container in the creation IR.\n */\nexport interface ContainerStartOp extends ElementOrContainerOpBase {\n  kind: OpKind.ContainerStart;\n}\n\n/**\n * Logical operation representing an empty container in the creation IR.\n */\nexport interface ContainerOp extends ElementOrContainerOpBase {\n  kind: OpKind.Container;\n}\n\n/**\n * Logical operation representing the end of a container structure in the creation IR.\n *\n * Pairs with an `ContainerStart` operation.\n */\nexport interface ContainerEndOp extends Op<CreateOp> {\n  kind: OpKind.ContainerEnd;\n\n  /**\n   * The `XrefId` of the element declared via `ContainerStart`.\n   */\n  xref: XrefId;\n\n  sourceSpan: ParseSourceSpan;\n}\n\n/**\n * Logical operation causing binding to be disabled in descendents of a non-bindable container.\n */\nexport interface DisableBindingsOp extends Op<CreateOp> {\n  kind: OpKind.DisableBindings;\n\n  /**\n   * `XrefId` of the element that was marked non-bindable.\n   */\n  xref: XrefId;\n}\n\nexport function createDisableBindingsOp(xref: XrefId): DisableBindingsOp {\n  return {\n    kind: OpKind.DisableBindings,\n    xref,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation causing binding to be re-enabled after visiting descendants of a non-bindable\n * container.\n */\nexport interface EnableBindingsOp extends Op<CreateOp> {\n  kind: OpKind.EnableBindings;\n\n  /**\n   * `XrefId` of the element that was marked non-bindable.\n   */\n  xref: XrefId;\n}\n\nexport function createEnableBindingsOp(xref: XrefId): EnableBindingsOp {\n  return {\n    kind: OpKind.EnableBindings,\n    xref,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing a text node in the creation IR.\n */\nexport interface TextOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Text;\n\n  /**\n   * `XrefId` used to reference this text node in other IR structures.\n   */\n  xref: XrefId;\n\n  /**\n   * The static initial value of the text node.\n   */\n  initialValue: string;\n\n  sourceSpan: ParseSourceSpan|null;\n}\n\n/**\n * Create a `TextOp`.\n */\nexport function createTextOp(\n    xref: XrefId, initialValue: string, sourceSpan: ParseSourceSpan|null): TextOp {\n  return {\n    kind: OpKind.Text,\n    xref,\n    initialValue,\n    sourceSpan,\n    ...TRAIT_CONSUMES_SLOT,\n    ...NEW_OP,\n  };\n}\n\n/**\n * Logical operation representing an event listener on an element in the creation IR.\n */\nexport interface ListenerOp extends Op<CreateOp>, UsesSlotIndexTrait {\n  kind: OpKind.Listener;\n\n  /**\n   * Name of the event which is being listened to.\n   */\n  name: string;\n\n  /**\n   * Tag name of the element on which this listener is placed.\n   */\n  tag: string;\n\n  /**\n   * A list of `UpdateOp`s representing the body of the event listener.\n   */\n  handlerOps: OpList<UpdateOp>;\n\n  /**\n   * Name of the function\n   */\n  handlerFnName: string|null;\n\n  /**\n   * Whether this listener is known to consume `$event` in its body.\n   */\n  consumesDollarEvent: boolean;\n\n  /**\n   * Whether the listener is listening for an animation event.\n   */\n  isAnimationListener: boolean;\n\n  /**\n   * The animation phase of the listener.\n   */\n  animationPhase: string|null;\n}\n\n/**\n * Create a `ListenerOp`.\n */\nexport function createListenerOp(target: XrefId, name: string, tag: string): ListenerOp {\n  return {\n    kind: OpKind.Listener,\n    target,\n    tag,\n    name,\n    handlerOps: new OpList(),\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    isAnimationListener: false,\n    animationPhase: null,\n    ...NEW_OP,\n    ...TRAIT_USES_SLOT_INDEX,\n  };\n}\n\n/**\n * Create a `ListenerOp` for an animation.\n */\nexport function createListenerOpForAnimation(\n    target: XrefId, name: string, animationPhase: string, tag: string): ListenerOp {\n  return {\n    kind: OpKind.Listener,\n    target,\n    tag,\n    name,\n    handlerOps: new OpList(),\n    handlerFnName: null,\n    consumesDollarEvent: false,\n    isAnimationListener: true,\n    animationPhase,\n    ...NEW_OP,\n    ...TRAIT_USES_SLOT_INDEX,\n  };\n}\n\nexport interface PipeOp extends Op<CreateOp>, ConsumesSlotOpTrait {\n  kind: OpKind.Pipe;\n  xref: XrefId;\n  name: string;\n}\n\nexport function createPipeOp(xref: XrefId, name: string): PipeOp {\n  return {\n    kind: OpKind.Pipe,\n    xref,\n    name,\n    ...NEW_OP,\n    ...TRAIT_CONSUMES_SLOT,\n  };\n}\n\n/**\n * Whether the active namespace is HTML, MathML, or SVG mode.\n */\nexport enum Namespace {\n  HTML,\n  SVG,\n  Math,\n}\n\n/**\n * An op corresponding to a namespace instruction, for switching between HTML, SVG, and MathML.\n */\nexport interface NamespaceOp extends Op<CreateOp> {\n  kind: OpKind.Namespace;\n  active: Namespace;\n}\n\nexport function createNamespaceOp(namespace: Namespace): NamespaceOp {\n  return {\n    kind: OpKind.Namespace,\n    active: namespace,\n    ...NEW_OP,\n  };\n}\n\n/**\n * An index into the `consts` array which is shared across the compilation of all views in a\n * component.\n */\nexport type ConstIndex = number&{__brand: 'ConstIndex'};\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../../../src/output/output_ast';\nimport {ParseSourceSpan} from '../../../../../../src/parse_util';\nimport {OpKind} from '../enums';\nimport {Op} from '../operations';\nimport {ConsumesVarsTrait, TRAIT_CONSUMES_VARS} from '../traits';\n\nimport {NEW_OP} from './shared';\n\nimport type {Interpolation, UpdateOp} from './update';\n\n\n/**\n * Logical operation representing a host binding to a property.\n */\nexport interface HostPropertyOp extends Op<UpdateOp>, ConsumesVarsTrait {\n  kind: OpKind.HostProperty;\n  name: string;\n  expression: o.Expression|Interpolation;\n\n  sourceSpan: ParseSourceSpan|null;\n}\n\nexport function createHostPropertyOp(\n    name: string, expression: o.Expression|Interpolation,\n    sourceSpan: ParseSourceSpan|null): HostPropertyOp {\n  return {\n    kind: OpKind.HostProperty,\n    name,\n    expression,\n    sourceSpan,\n    ...TRAIT_CONSUMES_VARS,\n    ...NEW_OP,\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../../constant_pool';\nimport * as o from '../../../output/output_ast';\nimport * as ir from '../ir';\n\n/**\n * A compilation unit is compiled into a template function.\n * Some example units are views and host bindings.\n */\nexport abstract class CompilationUnit {\n  /**\n   * List of creation operations for this view.\n   *\n   * Creation operations may internally contain other operations, including update operations.\n   */\n  readonly create = new ir.OpList<ir.CreateOp>();\n\n  /**\n   * List of update operations for this view.\n   */\n  readonly update = new ir.OpList<ir.UpdateOp>();\n  abstract readonly job: CompilationJob;\n\n  constructor(readonly xref: ir.XrefId) {}\n\n  /**\n   * Iterate over all `ir.Op`s within this view.\n   *\n   * Some operations may have child operations, which this iterator will visit.\n   */\n  * ops(): Generator<ir.CreateOp|ir.UpdateOp> {\n    for (const op of this.create) {\n      yield op;\n      if (op.kind === ir.OpKind.Listener) {\n        for (const listenerOp of op.handlerOps) {\n          yield listenerOp;\n        }\n      }\n    }\n    for (const op of this.update) {\n      yield op;\n    }\n  }\n\n  /**\n   * Name of the function which will be generated for this unit.\n   *\n   * May be `null` if not yet determined.\n   */\n  fnName: string|null = null;\n\n  /**\n   * Number of variable slots used within this view, or `null` if variables have not yet been\n   * counted.\n   */\n  vars: number|null = null;\n}\n\nexport interface CompilationJob {\n  get units(): Iterable<CompilationUnit>;\n\n  get fnSuffix(): string;\n\n  /**\n   * Whether to compile in compatibility mode, to imitate the output of `TemplateDefinitionBuilder`.\n   */\n  compatibility: ir.CompatibilityMode;\n\n  componentName: string;\n\n  /**\n   * The root compilation unit, such as the component's template, or the host binding's compilation\n   * unit.\n   */\n  root: CompilationUnit;\n\n  /**\n   * The constant pool for the job, which will be transformed into a constant array on the emitted\n   * function.\n   */\n  pool: ConstantPool;\n\n  /**\n   * Generate a new unique `ir.XrefId` in this job.\n   */\n  allocateXrefId(): ir.XrefId;\n}\n\nexport class HostBindingCompilationJob extends CompilationUnit implements CompilationJob {\n  readonly fnSuffix = 'HostBindings';\n\n  readonly units = [this];\n\n  /**\n   * Tracks the next `ir.XrefId` which can be assigned as template structures are ingested.\n   */\n  private nextXrefId: ir.XrefId;\n\n  // TODO: Perhaps we should accept a reference to the enclosing component, and get the name from\n  // there?\n  constructor(\n      readonly componentName: string, readonly pool: ConstantPool,\n      readonly compatibility: ir.CompatibilityMode) {\n    super(0 as ir.XrefId);\n    this.nextXrefId = 1 as ir.XrefId;\n  }\n\n  override get job() {\n    return this;\n  }\n\n  get root() {\n    return this;\n  }\n\n  allocateXrefId(): ir.XrefId {\n    return this.nextXrefId++ as ir.XrefId;\n  }\n}\n\n/**\n * Compilation-in-progress of a whole component's template, including the main template and any\n * embedded views or host bindings.\n */\nexport class ComponentCompilationJob implements CompilationJob {\n  readonly fnSuffix = 'Template';\n\n  /**\n   * Tracks the next `ir.XrefId` which can be assigned as template structures are ingested.\n   */\n  private nextXrefId: ir.XrefId = 0 as ir.XrefId;\n\n  /**\n   * Map of view IDs to `ViewCompilation`s.\n   */\n  readonly views = new Map<ir.XrefId, ViewCompilationUnit>();\n\n  get units(): Iterable<ViewCompilationUnit> {\n    return this.views.values();\n  }\n\n  /**\n   * Constant expressions used by operations within this component's compilation.\n   *\n   * This will eventually become the `consts` array in the component definition.\n   */\n  readonly consts: o.Expression[] = [];\n\n  /**\n   * The root view, representing the component's template.\n   */\n  readonly root: ViewCompilationUnit;\n\n  constructor(\n      readonly componentName: string, readonly pool: ConstantPool,\n      readonly compatibility: ir.CompatibilityMode) {\n    // Allocate the root view.\n    const root = new ViewCompilationUnit(this, this.allocateXrefId(), null);\n    this.views.set(root.xref, root);\n    this.root = root;\n  }\n\n  /**\n   * Add a `ViewCompilation` for a new embedded view to this compilation.\n   */\n  allocateView(parent: ir.XrefId): ViewCompilationUnit {\n    const view = new ViewCompilationUnit(this, this.allocateXrefId(), parent);\n    this.views.set(view.xref, view);\n    return view;\n  }\n\n  /**\n   * Generate a new unique `ir.XrefId` in this job.\n   */\n  allocateXrefId(): ir.XrefId {\n    return this.nextXrefId++ as ir.XrefId;\n  }\n\n  /**\n   * Add a constant `o.Expression` to the compilation and return its index in the `consts` array.\n   */\n  addConst(newConst: o.Expression): ir.ConstIndex {\n    for (let idx = 0; idx < this.consts.length; idx++) {\n      if (this.consts[idx].isEquivalent(newConst)) {\n        return idx as ir.ConstIndex;\n      }\n    }\n    const idx = this.consts.length;\n    this.consts.push(newConst);\n    return idx as ir.ConstIndex;\n  }\n}\n\n/**\n * Compilation-in-progress of an individual view within a template.\n */\nexport class ViewCompilationUnit extends CompilationUnit {\n  constructor(\n      readonly job: ComponentCompilationJob, xref: ir.XrefId, readonly parent: ir.XrefId|null) {\n    super(xref);\n  }\n\n  /**\n   * Map of declared variables available within this view to the property on the context object\n   * which they alias.\n   */\n  readonly contextVariables = new Map<string, string>();\n\n  /**\n   * Number of declaration slots used within this view, or `null` if slots have not yet been\n   * allocated.\n   */\n  decls: number|null = null;\n\n  get compatibility(): ir.CompatibilityMode {\n    return this.job.compatibility;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob, ComponentCompilationJob} from '../compilation';\n\n/**\n * Counts the number of variable slots used within each view, and stores that on the view itself, as\n * well as propagates it to the `ir.TemplateOp` for embedded views.\n */\nexport function phaseVarCounting(job: CompilationJob): void {\n  // First, count the vars used in each view, and update the view-level counter.\n  for (const unit of job.units) {\n    let varCount = 0;\n    for (const op of unit.ops()) {\n      if (ir.hasConsumesVarsTrait(op)) {\n        varCount += varsUsedByOp(op);\n      }\n\n      ir.visitExpressionsInOp(op, expr => {\n        if (!ir.isIrExpression(expr)) {\n          return;\n        }\n\n        // Some expressions require knowledge of the number of variable slots consumed.\n        if (ir.hasUsesVarOffsetTrait(expr)) {\n          expr.varOffset = varCount;\n        }\n\n        if (ir.hasConsumesVarsTrait(expr)) {\n          varCount += varsUsedByIrExpression(expr);\n        }\n      });\n    }\n\n    unit.vars = varCount;\n  }\n\n  if (job instanceof ComponentCompilationJob) {\n    // Add var counts for each view to the `ir.TemplateOp` which declares that view (if the view is\n    // an embedded view).\n    for (const view of job.views.values()) {\n      for (const op of view.create) {\n        if (op.kind !== ir.OpKind.Template) {\n          continue;\n        }\n\n        const childView = job.views.get(op.xref)!;\n        op.vars = childView.vars;\n      }\n    }\n  }\n}\n\n/**\n * Different operations that implement `ir.UsesVarsTrait` use different numbers of variables, so\n * count the variables used by any particular `op`.\n */\nfunction varsUsedByOp(op: (ir.CreateOp|ir.UpdateOp)&ir.ConsumesVarsTrait): number {\n  let slots: number;\n  switch (op.kind) {\n    case ir.OpKind.Property:\n    case ir.OpKind.HostProperty:\n    case ir.OpKind.Attribute:\n      // All of these bindings use 1 variable slot, plus 1 slot for every interpolated expression,\n      // if any.\n      slots = 1;\n      if (op.expression instanceof ir.Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case ir.OpKind.StyleProp:\n    case ir.OpKind.ClassProp:\n    case ir.OpKind.StyleMap:\n    case ir.OpKind.ClassMap:\n      // Style & class bindings use 2 variable slots, plus 1 slot for every interpolated expression,\n      // if any.\n      slots = 2;\n      if (op.expression instanceof ir.Interpolation) {\n        slots += op.expression.expressions.length;\n      }\n      return slots;\n    case ir.OpKind.InterpolateText:\n      // `ir.InterpolateTextOp`s use a variable slot for each dynamic expression.\n      return op.interpolation.expressions.length;\n    default:\n      throw new Error(`Unhandled op: ${ir.OpKind[op.kind]}`);\n  }\n}\n\nexport function varsUsedByIrExpression(expr: ir.Expression&ir.ConsumesVarsTrait): number {\n  switch (expr.kind) {\n    case ir.ExpressionKind.PureFunctionExpr:\n      return 1 + expr.args.length;\n    case ir.ExpressionKind.PipeBinding:\n      return 1 + expr.args.length;\n    case ir.ExpressionKind.PipeBindingVariadic:\n      return 1 + expr.numArgs;\n    default:\n      throw new Error(\n          `AssertionError: unhandled ConsumesVarsTrait expression ${expr.constructor.name}`);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\n\nimport type {ComponentCompilationJob} from '../compilation';\nimport {varsUsedByIrExpression} from './var_counting';\n\nexport function phaseAlignPipeVariadicVarOffset(cpl: ComponentCompilationJob): void {\n  for (const view of cpl.views.values()) {\n    for (const op of view.update) {\n      ir.visitExpressionsInOp(op, expr => {\n        if (!(expr instanceof ir.PipeBindingVariadicExpr)) {\n          return expr;\n        }\n\n        if (!(expr.args instanceof ir.PureFunctionExpr)) {\n          return expr;\n        }\n\n        if (expr.varOffset === null || expr.args.varOffset === null) {\n          throw new Error(`Must run after variable counting`);\n        }\n\n        // The structure of this variadic pipe expression is:\n        // PipeBindingVariadic(#, Y, PureFunction(X, ...ARGS))\n        // Where X and Y are the slot offsets for the variables used by these operations, and Y > X.\n\n        // In `TemplateDefinitionBuilder` the PipeBindingVariadic variable slots are allocated\n        // before the PureFunction slots, which is unusually out-of-order.\n        //\n        // To maintain identical output for the tests in question, we adjust the variable offsets of\n        // these two calls to emulate TDB's behavior. This is not perfect, because the ARGS of the\n        // PureFunction call may also allocate slots which by TDB's ordering would come after X, and\n        // we don't account for that. Still, this should be enough to pass the existing pipe tests.\n\n        // Put the PipeBindingVariadic vars where the PureFunction vars were previously allocated.\n        expr.varOffset = expr.args.varOffset;\n\n        // Put the PureFunction vars following the PipeBindingVariadic vars.\n        expr.args.varOffset = expr.varOffset + varsUsedByIrExpression(expr);\n      });\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob} from '../compilation';\n\n/**\n * Find any function calls to `$any`, excluding `this.$any`, and delete them.\n */\nexport function phaseFindAnyCasts(cpl: ComponentCompilationJob): void {\n  for (const [_, view] of cpl.views) {\n    for (const op of view.ops()) {\n      ir.transformExpressionsInOp(op, removeAnys, ir.VisitorContextFlag.None);\n    }\n  }\n}\n\nfunction removeAnys(e: o.Expression): o.Expression {\n  if (e instanceof o.InvokeFunctionExpr && e.fn instanceof ir.LexicalReadExpr &&\n      e.fn.name === '$any') {\n    if (e.args.length !== 1) {\n      throw new Error('The $any builtin function expects exactly one argument.');\n    }\n    return e.args[0];\n  }\n  return e;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Any changes here should be ported to the Angular Domino fork.\n// https://github.com/angular/domino/blob/main/lib/style_parser.js\n\nconst enum Char {\n  OpenParen = 40,\n  CloseParen = 41,\n  Colon = 58,\n  Semicolon = 59,\n  BackSlash = 92,\n  QuoteNone = 0,  // indicating we are not inside a quote\n  QuoteDouble = 34,\n  QuoteSingle = 39,\n}\n\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\nexport function parse(value: string): string[] {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  const styles: string[] = [];\n\n  let i = 0;\n  let parenDepth = 0;\n  let quote: Char = Char.QuoteNone;\n  let valueStart = 0;\n  let propStart = 0;\n  let currentProp: string|null = null;\n  while (i < value.length) {\n    const token = value.charCodeAt(i++) as Char;\n    switch (token) {\n      case Char.OpenParen:\n        parenDepth++;\n        break;\n      case Char.CloseParen:\n        parenDepth--;\n        break;\n      case Char.QuoteSingle:\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteSingle;\n        } else if (quote === Char.QuoteSingle && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.QuoteDouble:\n        // same logic as above\n        if (quote === Char.QuoteNone) {\n          quote = Char.QuoteDouble;\n        } else if (quote === Char.QuoteDouble && value.charCodeAt(i - 1) !== Char.BackSlash) {\n          quote = Char.QuoteNone;\n        }\n        break;\n      case Char.Colon:\n        if (!currentProp && parenDepth === 0 && quote === Char.QuoteNone) {\n          currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n          valueStart = i;\n        }\n        break;\n      case Char.Semicolon:\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === Char.QuoteNone) {\n          const styleVal = value.substring(valueStart, i - 1).trim();\n          styles.push(currentProp, styleVal);\n          propStart = i;\n          valueStart = 0;\n          currentProp = null;\n        }\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    const styleVal = value.slice(valueStart).trim();\n    styles.push(currentProp, styleVal);\n  }\n\n  return styles;\n}\n\nexport function hyphenate(value: string): string {\n  return value\n      .replace(\n          /[a-z][A-Z]/g,\n          v => {\n            return v.charAt(0) + '-' + v.charAt(1);\n          })\n      .toLowerCase();\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\nimport {ViewCompilationUnit} from '../compilation';\n\n/**\n * Gets a map of all elements in the given view by their xref id.\n */\nexport function getElementsByXrefId(view: ViewCompilationUnit) {\n  const elements = new Map<ir.XrefId, ir.ElementOrContainerOps>();\n  for (const op of view.create) {\n    if (!ir.isElementOrContainerOp(op)) {\n      continue;\n    }\n    elements.set(op.xref, op);\n  }\n  return elements;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../../../../core';\nimport * as o from '../../../../output/output_ast';\nimport {parse as parseStyle} from '../../../../render3/view/style_parser';\nimport * as ir from '../../ir';\nimport {ComponentCompilationJob, ViewCompilationUnit} from '../compilation';\nimport {getElementsByXrefId} from '../util/elements';\n\n/**\n * Find all attribute and binding ops, and collect them into the ElementAttribute structures.\n * In cases where no instruction needs to be generated for the attribute or binding, it is removed.\n */\nexport function phaseAttributeExtraction(cpl: ComponentCompilationJob): void {\n  for (const [_, view] of cpl.views) {\n    populateElementAttributes(view);\n  }\n}\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupElement(\n    elements: Map<ir.XrefId, ir.ElementOrContainerOps>, xref: ir.XrefId): ir.ElementOrContainerOps {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\n\n/**\n * Populates the ElementAttributes map for the given view, and removes ops for any bindings that do\n * not need further processing.\n */\nfunction populateElementAttributes(view: ViewCompilationUnit) {\n  const elements = getElementsByXrefId(view);\n\n  for (const op of view.ops()) {\n    let ownerOp: ReturnType<typeof lookupElement>;\n    switch (op.kind) {\n      case ir.OpKind.Attribute:\n        extractAttributeOp(view, op, elements);\n        break;\n      case ir.OpKind.Property:\n        if (op.isAnimationTrigger) {\n          continue;  // Don't extract animation properties.\n        }\n\n        ownerOp = lookupElement(elements, op.target);\n        ir.assertIsElementAttributes(ownerOp.attributes);\n\n        ownerOp.attributes.add(\n            op.isTemplate ? ir.BindingKind.Template : ir.BindingKind.Property, op.name, null);\n        break;\n      case ir.OpKind.StyleProp:\n      case ir.OpKind.ClassProp:\n        ownerOp = lookupElement(elements, op.target);\n        ir.assertIsElementAttributes(ownerOp.attributes);\n\n        // Empty StyleProperty and ClassName expressions are treated differently depending on\n        // compatibility mode.\n        if (view.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n            op.expression instanceof ir.EmptyExpr) {\n          // The old compiler treated empty style bindings as regular bindings for the purpose of\n          // directive matching. That behavior is incorrect, but we emulate it in compatibility\n          // mode.\n          ownerOp.attributes.add(ir.BindingKind.Property, op.name, null);\n        }\n        break;\n      case ir.OpKind.Listener:\n        if (op.isAnimationListener) {\n          continue;  // Don't extract animation listeners.\n        }\n        ownerOp = lookupElement(elements, op.target);\n        ir.assertIsElementAttributes(ownerOp.attributes);\n\n        ownerOp.attributes.add(ir.BindingKind.Property, op.name, null);\n        break;\n    }\n  }\n}\n\nfunction isStringLiteral(expr: o.Expression): expr is o.LiteralExpr&{value: string} {\n  return expr instanceof o.LiteralExpr && typeof expr.value === 'string';\n}\n\nfunction extractAttributeOp(\n    view: ViewCompilationUnit, op: ir.AttributeOp,\n    elements: Map<ir.XrefId, ir.ElementOrContainerOps>) {\n  if (op.expression instanceof ir.Interpolation) {\n    return;\n  }\n  const ownerOp = lookupElement(elements, op.target);\n  ir.assertIsElementAttributes(ownerOp.attributes);\n\n  if (op.name === 'style' && isStringLiteral(op.expression)) {\n    // TemplateDefinitionBuilder did not extract style attributes that had a security context.\n    if (view.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder &&\n        op.securityContext !== SecurityContext.NONE) {\n      return;\n    }\n\n    // Extract style attributes.\n    const parsedStyles = parseStyle(op.expression.value);\n    for (let i = 0; i < parsedStyles.length - 1; i += 2) {\n      ownerOp.attributes.add(\n          ir.BindingKind.StyleProperty, parsedStyles[i], o.literal(parsedStyles[i + 1]));\n    }\n    ir.OpList.remove(op as ir.UpdateOp);\n  } else {\n    // The old compiler only extracted string constants, so we emulate that behavior in\n    // compaitiblity mode, otherwise we optimize more aggressively.\n    let extractable = view.compatibility === ir.CompatibilityMode.TemplateDefinitionBuilder ?\n        (op.expression instanceof o.LiteralExpr && typeof op.expression.value === 'string') :\n        op.expression.isConstant();\n\n    // We don't need to generate instructions for attributes that can be extracted as consts.\n    if (extractable) {\n      ownerOp.attributes.add(\n          op.isTemplate ? ir.BindingKind.Template : ir.BindingKind.Attribute, op.name,\n          op.expression);\n      ir.OpList.remove(op as ir.UpdateOp);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as ir from '../../ir';\nimport {CompilationJob, HostBindingCompilationJob} from '../compilation';\n\n/**\n * Looks up an element in the given map by xref ID.\n */\nfunction lookupElement(\n    elements: Map<ir.XrefId, ir.ElementOrContainerOps>, xref: ir.XrefId): ir.ElementOrContainerOps {\n  const el = elements.get(xref);\n  if (el === undefined) {\n    throw new Error('All attributes should have an element-like target.');\n  }\n  return el;\n}\n\nexport function phaseBindingSpecialization(job: CompilationJob): void {\n  const elements = new Map<ir.XrefId, ir.ElementOrContainerOps>();\n  for (const unit of job.units) {\n    for (const op of unit.create) {\n      if (!ir.isElementOrContainerOp(op)) {\n        continue;\n      }\n      elements.set(op.xref, op);\n    }\n  }\n\n  for (const unit of job.units) {\n    for (const op of unit.ops()) {\n      if (op.kind !== ir.OpKind.Binding) {\n        continue;\n      }\n\n      switch (op.bindingKind) {\n        case ir.BindingKind.Attribute:\n          if (op.name === 'ngNonBindable') {\n            ir.OpList.remove<ir.UpdateOp>(op);\n            const target = lookupElement(elements, op.target);\n            target.nonBindable = true;\n          } else {\n            ir.OpList.replace<ir.UpdateOp>(\n                op,\n                ir.createAttributeOp(\n                    op.target, op.name, op.expression, op.securityContext, op.isTemplate,\n                    op.sourceSpan));\n          }\n          break;\n        case ir.BindingKind.Property:\n        case ir.BindingKind.Animation:\n          if (job instanceof HostBindingCompilationJob) {\n            // TODO: host property animations\n            ir.OpList.replace<ir.UpdateOp>(\n                op, ir.createHostPropertyOp(op.name, op.expression, op.sourceSpan));\n          } else {\n            ir.OpList.replace<ir.UpdateOp>(\n                op,\n                ir.createPropertyOp(\n                    op.target, op.name, op.expression, op.bindingKind === ir.BindingKind.Animation,\n                    op.securityContext, op.isTemplate, op.sourceSpan));\n          }\n\n          break;\n        case ir.BindingKind.I18n:\n        case ir.BindingKind.ClassName:\n        case ir.BindingKind.StyleProperty:\n          throw new Error(`Unhandled binding of kind ${ir.BindingKind[op.bindingKind]}`);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../../../../output/output_ast';\nimport {Identifiers as R3} from '../../../../render3/r3_identifiers';\nimport * as ir from '../../ir';\nimport {CompilationJob} from '../compilation';\n\nconst CHAINABLE = new Set([\n  R3.elementStart,\n  R3.elementEnd,\n  R3.element,\n  R3.property,\n  R3.hostProperty,\n  R3.styleProp,\n  R3.attribute,\n  R3.stylePropInterpolate1,\n  R3.stylePropInterpolate2,\n  R3.stylePropInterpolate3,\n  R3.stylePropInterpolate4,\n  R3.stylePropInterpolate5,\n  R3.stylePropInterpolate6,\n  R3.stylePropInterpolate7,\n  R3.stylePropInterpolate8,\n  R3.stylePropInterpolateV,\n  R3.classProp,\n  R3.listener,\n  R3.elementContainerStart,\n  R3.elementContainerEnd,\n  R3.elementContainer,\n  R3.listener,\n]);\n\n/**\n * Post-process a reified view compilation and convert sequential calls to chainable instructions\n * into chain calls.\n *\n * For example, two `elementStart` operations in sequence:\n *\n * ```typescript\n * elementStart(0, 'div');\n * elementStart(1, 'span');\n * ```\n *\n * Can be called as a chain instead:\n *\n * ```typescript\n * elementStart(0, 'div')(1, 'span');\n * ```\n */\nexport function phaseChaining(job: CompilationJob): void {\n  for (const unit of job.units) {\n    chainOperationsInList(unit.create);\n    chainOperationsInList(unit.update);\n  }\n}\n\nfunction chainOperationsInList(opList: ir.OpList<ir.CreateOp|ir.UpdateOp>): void {\n  let chain: Chain|null = null;\n  for (const op of opList) {\n    if (op.kind !== ir.OpKind.Statement || !(op.statement instanceof o.ExpressionStatement)) {\n      // This type of statement isn't chainable.\n      chain = null;\n      continue;\n    }\n    if (!(op.statement.expr instanceof o.InvokeFunctionExpr) ||\n        !(op.statement.expr.fn instanceof o.ExternalExpr)) {\n      // This is a statement, but not an instruction-type call, so not chainable.\n      chain = null;\n      continue;\n    }\n\n    const instruction = op.statement.expr.fn.value;\n    if (!CHAINABLE.has(instruction)) {\n      // This instruction isn't chainable.\n      chain = null;\n      continue;\n    }\n\n    // This instruction can be chained. It can either be added on to the previous chain (if\n    // compatible) or it can be the start of a new chain.\n    if (chain !== null && chain.instruction === instruction) {\n      // This instruction can be added onto the previous chain.\n      const expression = chain.expression.callFn(\n          op.statement.expr.args, op.statement.expr.sourceSpan, op.statement.expr.pure);\n      chain.expression = expression;\n      chain.op.statement = expression.toStmt();\n      ir.OpList.remove(op as ir.Op<ir.CreateOp|ir.UpdateOp>);\n    } else {\n      // Leave this instruction alone for now, but consider it the start of a new chain.\n      chain = {\n        op,\n        instruction,\n        expression: op.stat